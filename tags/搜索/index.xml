<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>搜索 on 悟剑阁</title>
    <link>https://sword865.github.io/tags/%E6%90%9C%E7%B4%A2/</link>
    <description>Recent content in 搜索 on 悟剑阁</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2015. All rights reserved.</copyright>
    <lastBuildDate>Mon, 27 Jul 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://sword865.github.io/tags/%E6%90%9C%E7%B4%A2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Elasticsearch-HttpServerModule</title>
      <link>https://sword865.github.io/archives/150/</link>
      <pubDate>Mon, 27 Jul 2015 00:00:00 +0000</pubDate>
      <guid>https://sword865.github.io/archives/150/</guid>
      <description>&lt;p&gt;HttpServerModule的请求主要由HttpServer中的HttpServerTransport （默认为NettyHttpServerTransport）类处理。&lt;/p&gt;&#xA;&lt;p&gt;NettyHttpServerTransport基于netty框架，负责监听并建立连接，信息的处理由内部类HttpChannelPipelineFactory 完成。&lt;/p&gt;&#xA;&lt;p&gt;每当产生一个连接时，都会发出一个ChannelEvent，该Event由一系列的ChannelHandler进行处理。&lt;/p&gt;&#xA;&lt;p&gt;为了方便组织，这些ChannelHandler被放在一条“流(pipeline)”里，一个ChannelEvent并不会主动的”流”经所有的Handler，而是由上一个Handler显式的调用ChannelPipeline.sendUp(Down)stream产生，并交给下一个Handler处理。&lt;/p&gt;&#xA;&lt;p&gt;换句话说，每个Handler接收到一个ChannelEvent，并处理结束后，如果需要继续处理，那么它需要调用sendUp(Down)stream新发起一个事件。如果它不再发起事件，那么处理就到此结束，即使它后面仍然有Handler没有执行。这个机制可以保证最大的灵活性，当然对Handler的先后顺序也有了更严格的要求。&lt;/p&gt;&#xA;&lt;p&gt;在流Pipeline里有一个Map(name2ctx)和一个链表(记录head和tail)，pipeline里面会调度关联的多个channelhandler的运行。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://sword865.github.io/images/_posts/0753391.png&#34;&gt;&lt;img src=&#34;https://sword865.github.io/images/_posts/0753391.png&#34; alt=&#34;channel pipeline&#34; /&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在NettyHttpServerTransport中，会流过的channelhandler就包括解码http请求(把多个HttpChunk拼起来并按http协议进行解析)和http请求处理。&lt;/p&gt;&#xA;&lt;p&gt;在处理http请求，数据流向为：HttpRequestHandler-&amp;gt;&lt;span class=&#34;s1&#34;&gt;NettyHttpServerTransport&lt;/span&gt;-&amp;gt;HttpServerAdapter(HttpServer的内部类Dispatche)-&amp;gt;RestController。&lt;/p&gt;&#xA;&lt;p&gt;RestController中的处理代码为：&lt;/p&gt;&#xA;&lt;pre class=&#34;lang:java decode:true &#34;&gt;&#xD;&#xA;void executeHandler(RestRequest request, RestChannel channel) throws Exception {&#xD;&#xA;        final RestHandler handler = getHandler(request);&#xD;&#xA;        if (handler != null) {&#xD;&#xA;            handler.handleRequest(request, channel);&#xD;&#xA;        } else {&#xD;&#xA;            if (request.method() == RestRequest.Method.OPTIONS) {&#xD;&#xA;                // when we have OPTIONS request, simply send OK by default &#xD;&#xA;                // (with the Access Control Origin header which gets automatically added)&#xD;&#xA;                channel.sendResponse(new BytesRestResponse(OK));&#xD;&#xA;            } else {&#xD;&#xA;                channel.sendResponse(new BytesRestResponse(&#xD;&#xA;                    BAD_REQUEST, &#xD;&#xA;                    &#34;No handler found for uri [&#34; + request.uri() + &#34;] and method [&#34; + request.method() + &#34;]&#34;&#xD;&#xA;                ));&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private RestHandler getHandler(RestRequest request) {&#xD;&#xA;        String path = getPath(request);&#xD;&#xA;        RestRequest.Method method = request.method();&#xD;&#xA;        if (method == RestRequest.Method.GET) {&#xD;&#xA;            return getHandlers.retrieve(path, request.params());&#xD;&#xA;        } else if (method == RestRequest.Method.POST) {&#xD;&#xA;            return postHandlers.retrieve(path, request.params());&#xD;&#xA;        } else if (method == RestRequest.Method.PUT) {&#xD;&#xA;            return putHandlers.retrieve(path, request.params());&#xD;&#xA;        } else if (method == RestRequest.Method.DELETE) {&#xD;&#xA;            return deleteHandlers.retrieve(path, request.params());&#xD;&#xA;        } else if (method == RestRequest.Method.HEAD) {&#xD;&#xA;            return headHandlers.retrieve(path, request.params());&#xD;&#xA;        } else if (method == RestRequest.Method.OPTIONS) {&#xD;&#xA;            return optionsHandlers.retrieve(path, request.params());&#xD;&#xA;        } else {&#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;    }&lt;/pre&gt;&#xD;&#xA;&lt;p&gt;void executeHandler(RestRequest request, RestChannel channel) throws Exception {&#xA;final RestHandler handler = getHandler(request);&#xA;if (handler != null) {&#xA;handler.handleRequest(request, channel);&#xA;} else {&#xA;if (request.method() == RestRequest.Method.OPTIONS) {&#xA;// when we have OPTIONS request, simply send OK by default (with the Access Control Origin header which gets automatically added)&#xA;channel.sendResponse(new BytesRestResponse(OK));&#xA;} else {&#xA;channel.sendResponse(new BytesRestResponse(BAD_REQUEST, &amp;ldquo;No handler found for uri [&amp;rdquo; + request.uri() + &amp;ldquo;] and method [&amp;rdquo; + request.method() + &amp;ldquo;]&amp;rdquo;));&#xA;}&#xA;}&#xA;}&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lucene索引文件学习</title>
      <link>https://sword865.github.io/archives/86/</link>
      <pubDate>Wed, 04 Feb 2015 00:00:00 +0000</pubDate>
      <guid>https://sword865.github.io/archives/86/</guid>
      <description>&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt; 最近在做搜索，抽空看一下lucene，资料挺多的，不过大部分都是3.x了……在对着官方文档大概看一下。&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;优化后的lucene索引文件(4.9.0)&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;&lt;img title=&#34;NewImage.png&#34; src=&#34;https://sword865.github.io/wp-content/uploads/2015/02/NewImage.png&#34; alt=&#34;NewImage&#34; width=&#34;200&#34; height=&#34;146&#34; border=&#34;0&#34; /&gt;&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;一、段文件&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;1.段文件：segments_5p和segments.gen。&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;segments.gen保存当前段文件版本信息。&lt;/span&gt;&lt;/p&gt;&#xA;&lt;ul style=&#34;color: #353833; font-family: Arial, Helvetica, sans-serif; font-size: 12px;&#34;&gt;&#xD;&#xA;  &lt;li&gt;&#xD;&#xA;    &lt;span style=&#34;font-size: 12px;&#34;&gt;&lt;tt style=&#34;font-size: 1.2em;&#34;&gt;segments.gen&lt;/tt&gt;: GenHeader, Generation, Generation, Footer&lt;/span&gt;&#xD;&#xA;  &lt;/li&gt;&#xD;&#xA;&lt;/ul&gt;&#xD;&#xA;&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;segments_N（segments_5p）保存最新的段的信息，包括段的个数，每个段的段名、文档数等信息。&lt;/span&gt;&lt;/p&gt;&#xA;&lt;ul style=&#34;font-size: 12px; color: #353833; font-family: Arial, Helvetica, sans-serif;&#34;&gt;&#xD;&#xA;  &lt;li&gt;&#xD;&#xA;    &lt;span style=&#34;font-size: 12px;&#34;&gt;&lt;tt style=&#34;font-size: 1.2em;&#34;&gt;segments_N&lt;/tt&gt;: Header, Version, NameCounter, SegCount, &lt;SegName, SegCodec, DelGen, DeletionCount, FieldInfosGen, DocValuesGen, UpdatesFiles&gt;&lt;sup style=&#34;font-size: 0.6em;&#34;&gt;SegCount&lt;/sup&gt;, CommitUserData, Footer&lt;/span&gt;&#xD;&#xA;  &lt;/li&gt;&#xD;&#xA;&lt;/ul&gt;&#xD;&#xA;&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;  源码参考：SegmentInfos.read(Directory directory, String segmentFileName):&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;2.段信息：*.si，存储段的基本信息。&lt;/span&gt;&lt;/p&gt;&#xA;&lt;ul style=&#34;color: #353833; font-family: Arial, Helvetica, sans-serif; font-size: 12px;&#34;&gt;&#xD;&#xA;  &lt;li&gt;&#xD;&#xA;    &lt;span style=&#34;font-size: 12px;&#34;&gt;&lt;tt style=&#34;font-size: 1.2em;&#34;&gt;.si&lt;/tt&gt;: Header, SegVersion, SegSize, IsCompoundFile, Diagnostics, Attributes, Files&lt;/span&gt;&#xD;&#xA;  &lt;/li&gt;&#xD;&#xA;&lt;/ul&gt;&#xD;&#xA;&lt;p&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;       只对4.0-4.5使用，新版已经抛弃了，可以无视。  &lt;/span&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
