<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编译原理 on 悟剑阁</title>
    <link>https://sword865.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</link>
    <description>Recent content in 编译原理 on 悟剑阁</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2015. All rights reserved.</copyright>
    <lastBuildDate>Sun, 08 Mar 2009 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://sword865.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>编译原理虎书java版本–Chapter 1</title>
      <link>https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/</link>
      <pubDate>Sun, 08 Mar 2009 00:00:00 +0000</pubDate>
      <guid>https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/</guid>
      <description>&lt;p&gt;Count.java&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class  Count&#xD;&#xA;{&#xD;&#xA;    int resolveStm(Stm stm){&#xD;&#xA;        int temp1=0,temp2=0;&#xD;&#xA;        if(stm.kind==1){&#xD;&#xA;            temp1=resolveStm(((CompoundStm)stm).stm1);&#xD;&#xA;            temp2=resolveStm(((CompoundStm)stm).stm2);&#xD;&#xA;            return temp1&amp;gt;temp2? temp1:temp2;&#xD;&#xA;        }else if(stm.kind==2){&#xD;&#xA;            return resolveExp(((AssignStm)stm).exp);&#xD;&#xA;        }else if (stm.kind==3){&#xD;&#xA;            return countExpInExpList(((PrintStm)stm).exps);&#xD;&#xA;        }else{&#xD;&#xA;            return 0;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    int countExpInExpList(ExpList expList){&#xD;&#xA;        if(expList.kind==1){&#xD;&#xA;            return 1;&#xD;&#xA;        }else if(expList.kind==2){&#xD;&#xA;            return 1+countExpInExpList(((PairExpList)expList).tail);&#xD;&#xA;        }else{&#xD;&#xA;            return 0;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    int resolveExp(Exp exp){&#xD;&#xA;        int temp1,temp2;&#xD;&#xA;        if(exp.kind==1){&#xD;&#xA;            return 0;&#xD;&#xA;        }else if(exp.kind==2){&#xD;&#xA;            return 0;&#xD;&#xA;        }else if(exp.kind==3){&#xD;&#xA;            temp1 = resolveExp(((OpExp)exp).left);&#xD;&#xA;            temp2 = resolveExp(((OpExp)exp).right);&#xD;&#xA;            return temp1&amp;gt;temp2?temp1:temp2;&#xD;&#xA;        }else if(exp.kind==4){&#xD;&#xA;            temp1=resolveStm(((EseqExp)exp).stm);&#xD;&#xA;            temp2=resolveExp(((EseqExp)exp).exp);&#xD;&#xA;            return temp1&amp;gt;temp2?temp1:temp2;&#xD;&#xA;        }else{&#xD;&#xA;            return 0;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    int resolveExpList(ExpList expList){&#xD;&#xA;        int temp1,temp2;&#xD;&#xA;        if(expList.kind==2){&#xD;&#xA;            temp1 = resolveExp(((PairExpList)expList).head);&#xD;&#xA;            temp2 = resolveExpList(((PairExpList)expList).tail);&#xD;&#xA;            return temp1&amp;gt;temp2?temp1:temp2;&#xD;&#xA;        }else if(expList.kind==1){&#xD;&#xA;            return resolveExp(((LastExpList)expList).last);&#xD;&#xA;        }else{&#xD;&#xA;            return 0;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;Interp.java&#xD;&#xA;public class  Interp&#xD;&#xA;{&#xD;&#xA;    void startinterpStm(Stm stm){&#xD;&#xA;        Table t=new Table(null,0,null);&#xD;&#xA;        interpStm(stm,t);&#xD;&#xA;    }&#xD;&#xA;    Table interpStm(Stm stm,Table t){&#xD;&#xA;        if(stm.kind==1){&#xD;&#xA;            Table t1=interpStm(((CompoundStm)stm).stm1,t);&#xD;&#xA;            Table t2=interpStm(((CompoundStm)stm).stm2,t1);&#xD;&#xA;            return t2;&#xD;&#xA;        }else if(stm.kind==2){&#xD;&#xA;            IntAndTable it1 = interExp(((AssignStm)stm).exp,t);&#xD;&#xA;            Table t1=update(it1.t,((AssignStm)stm).id,it1.i);&#xD;&#xA;            return t1;&#xD;&#xA;        }else if(stm.kind==3){&#xD;&#xA;            printExplist(((PrintStm)stm).exps,t);&#xD;&#xA;            return t;&#xD;&#xA;        }else{&#xD;&#xA;            return t;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    IntAndTable interExp(Exp exp,Table t){&#xD;&#xA;        if(exp.kind==1){&#xD;&#xA;            int temp=lookup(t,((IdExp)exp).id);&#xD;&#xA;            return new IntAndTable(temp,t);&#xD;&#xA;        }else if(exp.kind==2){&#xD;&#xA;            return new IntAndTable(((NumExp)exp).num,t);&#xD;&#xA;        }else if(exp.kind==3){&#xD;&#xA;            IntAndTable it1= interExp(((OpExp)exp).left,t);&#xD;&#xA;            IntAndTable it2= interExp(((OpExp)exp).right,it1.t);&#xD;&#xA;            int x1,x2,result;&#xD;&#xA;            x1=it1.i;&#xD;&#xA;            x2=it2.i;&#xD;&#xA;            if(((OpExp)exp).oper==1){&#xD;&#xA;                result=x1+x2;&#xD;&#xA;            }else if(((OpExp)exp).oper==2){&#xD;&#xA;                result=x1-x2;&#xD;&#xA;            }else if(((OpExp)exp).oper==3){&#xD;&#xA;                result=x1*x2;&#xD;&#xA;            }else if(((OpExp)exp).oper==4){&#xD;&#xA;                result=x1/x2;&#xD;&#xA;            }else{&#xD;&#xA;                result=0;&#xD;&#xA;            }&#xD;&#xA;            return new IntAndTable(result,t);&#xD;&#xA;        }else if(exp.kind==4){&#xD;&#xA;            Table t1=interpStm(((EseqExp)exp).stm,t);&#xD;&#xA;            IntAndTable t3= interExp(((EseqExp)exp).exp,t1);&#xD;&#xA;            return t3;&#xD;&#xA;        }else{&#xD;&#xA;            return new IntAndTable(0,t);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    Table update(Table t1,String i,int v){&#xD;&#xA;        Table t2=new Table(i,v,t1);&#xD;&#xA;        return t2;&#xD;&#xA;    }&#xD;&#xA;    int lookup(Table t,String key){&#xD;&#xA;        if(key.compareTo(t.id)==0){&#xD;&#xA;            return t.value;&#xD;&#xA;        }else return lookup(t.tail,key);&#xD;&#xA;    }&#xD;&#xA;    void printExplist(ExpList exps,Table t){&#xD;&#xA;        if(exps.kind==1){&#xD;&#xA;            IntAndTable temp=interExp(((LastExpList)exps).last,t);&#xD;&#xA;            System.out.println(temp.i);&#xD;&#xA;        }else if(exps.kind==2){&#xD;&#xA;            IntAndTable temp=interExp(((PairExpList)exps).head,t);&#xD;&#xA;            System.out.print(temp.i+&amp;quot;&amp;quot;);&#xD;&#xA;            printExplist(((PairExpList)exps).tail,t);&#xD;&#xA;        }else return;&#xD;&#xA;    }&#xD;&#xA;// IntAndTable interExpList(ExpList explist,Table t){&#xD;&#xA;// }&#xD;&#xA;}&#xD;&#xA;class Table&#xD;&#xA;{&#xD;&#xA;    String id;&#xD;&#xA;    int value;&#xD;&#xA;    Table tail;&#xD;&#xA;    Table(String i,int v,Table t){id=i;value=v;tail=t;}&#xD;&#xA;}&#xD;&#xA;class IntAndTable&#xD;&#xA;{&#xD;&#xA;    int i;&#xD;&#xA;    Table t;&#xD;&#xA;    IntAndTable(int ii,Table tt){i=ii;t=tt;};&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>编译原理虎书java版本–Chapter 2-3</title>
      <link>https://sword865.github.io/posts/archives/2009-03-14-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-2-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://sword865.github.io/posts/archives/2009-03-14-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-2-3/</guid>
      <description>&lt;p&gt;文件：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;options {&#xD;&#xA;    JAVA_UNICODE_ESCAPE = true;&#xD;&#xA;}&#xD;&#xA;PARSER_BEGIN(MiniJavaParser)&#xD;&#xA;public class MiniJavaParser {}&#xD;&#xA;PARSER_END(MiniJavaParser)&#xD;&#xA;// Insert a specification of a lexical analysis here.&#xD;&#xA;TOKEN :&#xD;&#xA;{&#xD;&#xA;    &amp;lt; LPAREN: &amp;quot;(&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; RPAREN: &amp;quot;)&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; LSQPAREN: &amp;quot;[&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; RSQPAREN: &amp;quot;]&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; LBRACE: &amp;quot;{&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; RBRACE: &amp;quot;}&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; DOT: &amp;quot;.&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; ASSIGN: &amp;quot;=&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; LT: &amp;quot;&amp;lt;&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; PLUS: &amp;quot;+&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; MINUS: &amp;quot;-&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; AND : &amp;quot;&amp;amp;&amp;amp;&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; NOT : &amp;quot;!&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; SEMICOLON: &amp;quot;;&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; PUBLIC: &amp;quot;public&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; RETURN: &amp;quot;return&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; BOOLEAN: &amp;quot;boolean&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; CLASS: &amp;quot;class&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; INTERFACE: &amp;quot;interface&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; ELSE: &amp;quot;else&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; EXTENDS: &amp;quot;extends&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; FALSE: &amp;quot;false&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; IF: &amp;quot;if&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; WHILE: &amp;quot;while&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; INTEGER: &amp;quot;int&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; LENGTH: &amp;quot;length&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; MAIN: &amp;quot;main&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; NEW: &amp;quot;new&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; STATIC: &amp;quot;static&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; STRING: &amp;quot;String&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; THIS: &amp;quot;this&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; TRUE: &amp;quot;true&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; PRINT: &amp;quot;System.out.println&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; VOID: &amp;quot;void&amp;quot; &amp;gt;&#xD;&#xA;    }&#xD;&#xA;    TOKEN : /* LITERALS */&#xD;&#xA;    {&#xD;&#xA;        &amp;lt; INTEGER_LITERAL: ( [&amp;quot;1&amp;quot;-&amp;quot;9&amp;quot;] ([&amp;quot;0&amp;quot;-&amp;quot;9&amp;quot;])* | &amp;quot;0&amp;quot; ) &amp;gt;&#xD;&#xA;    }&#xD;&#xA;    TOKEN : /* IDENTIFIERS */&#xD;&#xA;    {&#xD;&#xA;        &amp;lt; IDENTIFIER: (|)* &amp;gt;&#xD;&#xA;        |&#xD;&#xA;        &amp;lt; #LETTER:&#xD;&#xA;        [&#xD;&#xA;        &amp;quot;u0024&amp;quot;,&#xD;&#xA;        &amp;quot;u0041&amp;quot;-&amp;quot;u005a&amp;quot;,&#xD;&#xA;        &amp;quot;u005f&amp;quot;,&#xD;&#xA;        &amp;quot;u0061&amp;quot;-&amp;quot;u007a&amp;quot;,&#xD;&#xA;        &amp;quot;u00c0&amp;quot;-&amp;quot;u00d6&amp;quot;,&#xD;&#xA;        &amp;quot;u00d8&amp;quot;-&amp;quot;u00f6&amp;quot;,&#xD;&#xA;        &amp;quot;u00f8&amp;quot;-&amp;quot;u00ff&amp;quot;,&#xD;&#xA;        &amp;quot;u0100&amp;quot;-&amp;quot;u1fff&amp;quot;,&#xD;&#xA;        &amp;quot;u3040&amp;quot;-&amp;quot;u318f&amp;quot;,&#xD;&#xA;        &amp;quot;u3300&amp;quot;-&amp;quot;u337f&amp;quot;,&#xD;&#xA;        &amp;quot;u3400&amp;quot;-&amp;quot;u3d2d&amp;quot;,&#xD;&#xA;        &amp;quot;u4e00&amp;quot;-&amp;quot;u9fff&amp;quot;,&#xD;&#xA;        &amp;quot;uf900&amp;quot;-&amp;quot;ufaff&amp;quot;&#xD;&#xA;        ]&#xD;&#xA;        |&#xD;&#xA;        &amp;lt; #DIGIT:&#xD;&#xA;        [&#xD;&#xA;        &amp;quot;u0030&amp;quot;-&amp;quot;u0039&amp;quot;,&#xD;&#xA;        &amp;quot;u0660&amp;quot;-&amp;quot;u0669&amp;quot;,&#xD;&#xA;        &amp;quot;u06f0&amp;quot;-&amp;quot;u06f9&amp;quot;,&#xD;&#xA;        &amp;quot;u0966&amp;quot;-&amp;quot;u096f&amp;quot;,&#xD;&#xA;        &amp;quot;u09e6&amp;quot;-&amp;quot;u09ef&amp;quot;,&#xD;&#xA;        &amp;quot;u0a66&amp;quot;-&amp;quot;u0a6f&amp;quot;,&#xD;&#xA;        &amp;quot;u0ae6&amp;quot;-&amp;quot;u0aef&amp;quot;,&#xD;&#xA;        &amp;quot;u0b66&amp;quot;-&amp;quot;u0b6f&amp;quot;,&#xD;&#xA;        &amp;quot;u0be7&amp;quot;-&amp;quot;u0bef&amp;quot;,&#xD;&#xA;        &amp;quot;u0c66&amp;quot;-&amp;quot;u0c6f&amp;quot;,&#xD;&#xA;        &amp;quot;u0ce6&amp;quot;-&amp;quot;u0cef&amp;quot;,&#xD;&#xA;        &amp;quot;u0d66&amp;quot;-&amp;quot;u0d6f&amp;quot;,&#xD;&#xA;        &amp;quot;u0e50&amp;quot;-&amp;quot;u0e59&amp;quot;,&#xD;&#xA;        &amp;quot;u0ed0&amp;quot;-&amp;quot;u0ed9&amp;quot;,&#xD;&#xA;        &amp;quot;u1040&amp;quot;-&amp;quot;u1049&amp;quot;&#xD;&#xA;        ]&#xD;&#xA;    }&#xD;&#xA;    SKIP :&#xD;&#xA;    {&#xD;&#xA;        &amp;lt; &amp;quot; &amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; &amp;quot;t&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; &amp;quot;n&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; &amp;quot;r&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt; &amp;quot;//&amp;quot; (~[&amp;quot;n&amp;quot;])* &amp;quot;n&amp;quot; &amp;gt;&#xD;&#xA;        | &amp;lt;&amp;quot;/*&amp;quot; (~[&amp;quot;*&amp;quot;])* &amp;quot;*&amp;quot; (~[&amp;quot;/&amp;quot;] (~[&amp;quot;*&amp;quot;])* &amp;quot;*&amp;quot;)* &amp;quot;/&amp;quot;&amp;gt;&#xD;&#xA;    }&#xD;&#xA;    // The following is a simple grammar that will allow you&#xD;&#xA;    // to test the generated lexer.&#xD;&#xA;    void Program() :&#xD;&#xA;    {}&#xD;&#xA;    {&#xD;&#xA;        MainClass() (ClassDecl())*&#xD;&#xA;    }&#xD;&#xA;    void MainClass() :&#xD;&#xA;    {}&#xD;&#xA;    {&#xD;&#xA;        &amp;quot;class&amp;quot; &amp;quot;{&amp;quot; &amp;quot;public&amp;quot; &amp;quot;static&amp;quot; &amp;quot;void&amp;quot; &amp;quot;main&amp;quot; &amp;quot;(&amp;quot; &amp;quot;String&amp;quot; &amp;quot;[&amp;quot; &amp;quot;]&amp;quot; &amp;quot;{&amp;quot; Statement() &amp;quot;}&amp;quot; &amp;quot;}&amp;quot;&#xD;&#xA;    }&#xD;&#xA;    void ext() :&#xD;&#xA;    {}&#xD;&#xA;    {&#xD;&#xA;        (&amp;quot;extends&amp;quot;  )?&#xD;&#xA;    }&#xD;&#xA;    void ClassDecl() :&#xD;&#xA;    {}&#xD;&#xA;    {&#xD;&#xA;        &amp;quot;class&amp;quot; ext()  &amp;quot;{&amp;quot; (VarDecl())* (MethodDecl())* &amp;quot;}&amp;quot;&#xD;&#xA;    }&#xD;&#xA;    void VarDecl():&#xD;&#xA;    {}&#xD;&#xA;    { Type() &amp;quot;;&amp;quot;}&#xD;&#xA;    void MethodDecl():&#xD;&#xA;    {}&#xD;&#xA;    {&amp;quot;public&amp;quot; Type()&#xD;&#xA;        &amp;quot;(&amp;quot; FormaList() &amp;quot;)&amp;quot;&#xD;&#xA;        &amp;quot;{&amp;quot; ( LOOKAHEAD(2) VarDecl() )* (Statement())*  &amp;quot;return&amp;quot; Exp() &amp;quot;;&amp;quot; &amp;quot;}&amp;quot;&#xD;&#xA;    }&#xD;&#xA;    void FormaList():&#xD;&#xA;    {}&#xD;&#xA;    {(Type()  &amp;quot;FormalRest()&amp;quot;)?}&#xD;&#xA;    void FormaRest():&#xD;&#xA;    {}&#xD;&#xA;    {&amp;quot;,&amp;quot; Type() }&#xD;&#xA;    void Type():&#xD;&#xA;    {}&#xD;&#xA;    {&#xD;&#xA;        |&amp;quot;boolean&amp;quot;&#xD;&#xA;        |LOOKAHEAD(2)&#xD;&#xA;        &amp;quot;int&amp;quot;&#xD;&#xA;        |&amp;quot;int&amp;quot; &amp;quot;[&amp;quot; &amp;quot;]&amp;quot;&#xD;&#xA;    }&#xD;&#xA;    void Statement():&#xD;&#xA;    {}&#xD;&#xA;    {&amp;quot;{&amp;quot; (Statement())* &amp;quot;}&amp;quot;&#xD;&#xA;    |&amp;quot;while&amp;quot; &amp;quot;(&amp;quot; Exp() &amp;quot;)&amp;quot; Statement()&#xD;&#xA;    |&amp;quot;System.out.println&amp;quot;  &amp;quot;(&amp;quot; Exp() &amp;quot;)&amp;quot;&#xD;&#xA;    | instat1() &amp;quot;=&amp;quot; Exp() &amp;quot;;&amp;quot;&#xD;&#xA;    |&amp;quot;if&amp;quot; &amp;quot;(&amp;quot; Exp() &amp;quot;)&amp;quot; Statement() inif()&#xD;&#xA;}&#xD;&#xA;void inif():&#xD;&#xA;{}&#xD;&#xA;{(LOOKAHEAD(2) &amp;quot;else&amp;quot; Statement())?}&#xD;&#xA;void instat1():&#xD;&#xA;{}&#xD;&#xA;{(&amp;quot;[&amp;quot; Exp() &amp;quot;]&amp;quot;)?}&#xD;&#xA;void Exp():&#xD;&#xA;{}&#xD;&#xA;{Expa() (LOOKAHEAD(2) (Expb()))?&#xD;&#xA;}&#xD;&#xA;void Expa():&#xD;&#xA;{}&#xD;&#xA;{&amp;quot;true&amp;quot;&#xD;&#xA;    |&amp;quot;false&amp;quot;&#xD;&#xA;    |&#xD;&#xA;    |&amp;quot;this&amp;quot;&#xD;&#xA;    |&amp;quot;!&amp;quot; Exp()&#xD;&#xA;    |&amp;quot;(&amp;quot; Exp() &amp;quot;)&amp;quot;&#xD;&#xA;    |LOOKAHEAD(2)&#xD;&#xA;    &amp;quot;new&amp;quot; &amp;quot;int&amp;quot; &amp;quot;[&amp;quot; Exp() &amp;quot;]&amp;quot;&#xD;&#xA;    |&amp;quot;new&amp;quot; &amp;quot;(&amp;quot; &amp;quot;)&amp;quot;&#xD;&#xA;}&#xD;&#xA;void Expb():&#xD;&#xA;{}&#xD;&#xA;{&#xD;&#xA;    op() Exp()&#xD;&#xA;    |&amp;quot;[&amp;quot; Exp() &amp;quot;]&amp;quot;Exp()&#xD;&#xA;    |LOOKAHEAD(2)&#xD;&#xA;    &amp;quot;.&amp;quot; &amp;quot;length&amp;quot;&#xD;&#xA;    |&amp;quot;.&amp;quot;&#xD;&#xA;}&#xD;&#xA;void op():&#xD;&#xA;{}&#xD;&#xA;{&amp;quot;&amp;amp;&amp;amp;&amp;quot;&#xD;&#xA;    |&amp;quot;&amp;lt;&amp;quot;&#xD;&#xA;    |&amp;quot;+&amp;quot;&#xD;&#xA;    |&amp;quot;-&amp;quot;&#xD;&#xA;    |&amp;quot;*&amp;quot;}&#xD;&#xA;    void ExpList():&#xD;&#xA;    {}&#xD;&#xA;    {(Exp()  (ExpRest())*)?}&#xD;&#xA;    void ExpRest():&#xD;&#xA;    {}&#xD;&#xA;    {&amp;quot;,&amp;quot; Exp()}&#xD;&#xA;    void Goal() :&#xD;&#xA;    {}&#xD;&#xA;    {&#xD;&#xA;        ( MiniJavaToken() )*&#xD;&#xA;    }&#xD;&#xA;    void MiniJavaToken():&#xD;&#xA;    {}&#xD;&#xA;    {&#xD;&#xA;        &amp;quot;class&amp;quot;  |  | &amp;quot;{&amp;quot; | &amp;quot;public&amp;quot; | &amp;quot;static&amp;quot; | &amp;quot;void&amp;quot; |&#xD;&#xA;            &amp;quot;main&amp;quot; | &amp;quot;(&amp;quot; | &amp;quot;String&amp;quot;  | &amp;quot;[&amp;quot; | &amp;quot;]&amp;quot; | &amp;quot;)&amp;quot; | &amp;quot;}&amp;quot; | &amp;quot;extends&amp;quot; | &amp;quot;;&amp;quot;&#xD;&#xA;            | &amp;quot;return&amp;quot; | &amp;quot;,&amp;quot; | &amp;quot;int&amp;quot; | &amp;quot;boolean&amp;quot; | &amp;quot;=&amp;quot; | &amp;quot;if&amp;quot; | &amp;quot;else&amp;quot; | &amp;quot;while&amp;quot;&#xD;&#xA;            | &amp;quot;System.out.println&amp;quot; | &amp;quot;&amp;amp;&amp;amp;&amp;quot; | &amp;quot;&amp;lt;&amp;quot; | &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;*&amp;quot; | &amp;quot;.&amp;quot; |&#xD;&#xA;            &amp;quot;length&amp;quot; | | &amp;quot;true&amp;quot; | &amp;quot;false&amp;quot; | &amp;quot;this&amp;quot; | &amp;quot;new&amp;quot; |&#xD;&#xA;            &amp;quot;!&amp;quot;&#xD;&#xA;    }&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
