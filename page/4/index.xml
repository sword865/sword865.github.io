<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>悟剑阁</title>
    <link>https://sword865.github.io/</link>
    <description>Recent content on 悟剑阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2015. All rights reserved.</copyright>
    <lastBuildDate>Sat, 05 Jul 2025 15:03:26 +0800</lastBuildDate>
    
        <atom:link href="https://sword865.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>算法总结1—贝叶斯分类器</title>
        <link>https://sword865.github.io/posts/archives/2009-09-05-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%931-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</link>
        <pubDate>Sat, 05 Sep 2009 00:00:00 +0000</pubDate>
        
        <guid>https://sword865.github.io/posts/archives/2009-09-05-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%931-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</guid>
        <description>悟剑阁 https://sword865.github.io/posts/archives/2009-09-05-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%931-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/ -&lt;p&gt; 这几天以很快的速度翻完了&amp;lt;集体智慧编程&amp;gt;,因为只是对里面的算法感兴趣,对那些web2.0的应用没什么感觉,所以很多地方都是一扫而过,现在按最后一章的顺序来对所有相关的算法作一个详细的复习….&lt;/p&gt;
&lt;p&gt;这个是第一篇……贝叶斯分类器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数学基础：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件概率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：设A, B是两个事件，且P(A)&amp;gt;0 称P(B∣A)=P(AB)/P(A)为在条件 A下发生的条件事件B发生的条件概率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乘法公式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设P(A)&amp;gt;0，则有P(AB)=P(B∣A)P(A)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全概率公式和贝叶斯公式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: 设S为试验E的样本空间，B1, B2, …Bn为E的一组事件，若BiBj=Ф, i≠j, i, j=1, 2, …,n; B1∪B2∪…∪Bn=S则称B1, B2, …, Bn为样本空间的一个划分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设试验E的样本空间为，A为E的事件，B1, B2, …,Bn为的一个划分，且P(Bi)&amp;gt;0(i=1, 2, …n)，则P(A)=P(A∣B1)P(B1)+P(A∣B2)+ …+P(A∣Bn)P(Bn)称为全概率公式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设试验E的样本空间为S，A为E的事件，B1, B2, …,Bn为的一个划分，则P(Bi∣A)=P(A∣Bi)P(Bi)/∑P(B｜Aj)P(Aj)=P(B｜Ai)P(Ai)/P(B)称为贝叶斯公式。&lt;/p&gt;
&lt;p&gt;说明：i，j均为下标，求和均是1到n&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;贝叶斯分类器原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过某些特征对不同的内容进行分类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何可以用来判断内容中具备或缺失的东西。如要对文档进行分类时，所谓的内容就是文档，特征就是文档中的单词(当然你也可以选择其他合理的东西)&lt;/p&gt;
&lt;p&gt;当向贝叶斯分类器输入一个要进行分类的样本后，分类器会先对该样本进行分析，确定其特征，然后将根据这些特征时，计算样本属于各分类的概率。&lt;/p&gt;
&lt;p&gt;朴素贝叶斯分类器的具体工作步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习：向分类器输入一系列的训练数据，注意这些数据是包括其所属类别的，分类器将对训练数据进行分析，计算出&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1.各个特征在各个分类中出现的概率(=某分类中具有该特征的数据数目/该分类数目)如先计算出各个单词在各种分类的文档出现的概率。&lt;/p&gt;
&lt;p&gt;将该概率作为某分类下某特征出现的条件概率P(feature|category)&lt;/p&gt;
&lt;p&gt;2.任选一个样本属于某分类的概率(=某分类文章数 / 文章总数)&lt;/p&gt;
&lt;p&gt;记该概率为p(category)&lt;/p&gt;
&lt;p&gt;在朴素的贝叶斯分类器中，我们假设将要组合的各个概率相互独立(当然，很多时候并非如此。我们有时会发现，当样本拥有某一特征时，则它就更可能拥有另一项特征。)&lt;/p&gt;
&lt;p&gt;2)分类计算：在向分类器提供大量学习数据后，我们就可以用它对新的样本进行分类了。&lt;/p&gt;
&lt;p&gt;首先对样本进行分析，找出其具有的各种特征，利用这些特征，我们来计算各个分类中出现该样本的概率p(sample | category)。为了完成这一计算，我们只要简单将该分类下在该文档中出现过的特征出现的条件概率相乘即可。即∏P(feature | category) 这里的feature是该样本拥有的所有特征。&lt;/p&gt;
&lt;p&gt;但是，我们实际要计算的是P (category | sample),即给定样本属于某分类的条件概率。&lt;/p&gt;
&lt;p&gt;这里，就用到了贝叶斯定理：P(A | B)=P(B | A)P(A) / P(B)&lt;/p&gt;
&lt;p&gt;这里就是：P(category | sample)= P(sample | category)P(category) / P(sample)&lt;/p&gt;
&lt;p&gt;其中，P(sample | category)P(category)都已经在学习中计算得到，而P(sample)是样本出现 的概率，我们可以计算它，但是这是没有意义的，因为我们会计算出各个分类的条件概率，然后比较它们的大小确定样本所属的分类，而对各个条件概率而言p(sample)是完全一样的。所以，我们就省去了对它的计算。&lt;/p&gt;
&lt;p&gt;这样，我们就可以确定一个样本的具体分类了。&lt;/p&gt;
&lt;p&gt;当然，以上算法是有很多改进的，比如对各分类定义一个最小阀值，一旦没有达到任一分类的阀值，则归属为未知。&lt;/p&gt;
&lt;p&gt;另外，针对朴素的贝叶斯分类器的缺点，还有很多其他的计算方法，如费舍尔方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;费舍尔方法&lt;/strong&gt;为文档中的每个特征都求得了分类的概率，然后又将这些概率组合起来，并判断其是否有可能构成一个随机集合。该方法还会返回每个分类的概率，这些概率彼此间可以进行比较。尽管这种方法更为复杂，但是因为它在为分类选择临界值（cutoff）时允许更大的灵活性，所以还是值得一学的。&lt;/p&gt;
&lt;p&gt;不同于之前计算的P(feature | category)，费舍尔方法将计算P(category | feature)，即拥有某一特征的样本属于某分类的概率。首先用P(具有指定特征的属于某分类的样本数 |具有指定特征的样本数)作为这一概率，然后将特征出现在所有所有分类中的概率fresum=∑P(category | feature),最后用P(category | feature) / fresum作为新的P(category | feature)。(这样修正后的值将比修正前更加有效)&lt;/p&gt;
&lt;p&gt;然后，我们就可以通过将各个特征的概率组合起来得到待分类样本所属的类别了。我们可以通过简单的相乘完成这一目的，虽然这里也作了相互独立的假设，但也比之前号上很多了。费舍尔方法的计算方法是将所有概率相乘后取自然对数，在乘以-2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;朴素的贝叶斯分类器最大的优势是他在接受大量数据训练和查询时的高速度。尤其当训练量递增时更是如此(我们可以分多次的对其进行学习的训练，而一些其他的方法如决策树和支持向量机要一次传送整个训练数据集)&lt;/p&gt;
&lt;p&gt;另一个优点是，其对分类器的学习情况有着比较简单的解释，我们可以简单的通过查询学习时计算的一些概率值来了解其分类原理。&lt;/p&gt;
&lt;p&gt;朴素的贝叶斯分类最大的缺陷是它无法处理特征符合所产生的变化(即前面提到过的实际上难以满足的相互独立)&lt;/p&gt;
&lt;p&gt;终于写完了…好累啊…还有8个算法……&lt;/p&gt;
- https://sword865.github.io/posts/archives/2009-09-05-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%931-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/ - Copyright (c) 2015. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>读《你的灯亮这么》—走出问题的乌托邦</title>
        <link>https://sword865.github.io/posts/archives/2009-08-25-%E8%AF%BB%E4%BD%A0%E7%9A%84%E7%81%AF%E4%BA%AE%E8%BF%99%E4%B9%88-%E8%B5%B0%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84%E4%B9%8C%E6%89%98%E9%82%A6/</link>
        <pubDate>Tue, 25 Aug 2009 00:00:00 +0000</pubDate>
        
        <guid>https://sword865.github.io/posts/archives/2009-08-25-%E8%AF%BB%E4%BD%A0%E7%9A%84%E7%81%AF%E4%BA%AE%E8%BF%99%E4%B9%88-%E8%B5%B0%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84%E4%B9%8C%E6%89%98%E9%82%A6/</guid>
        <description>悟剑阁 https://sword865.github.io/posts/archives/2009-08-25-%E8%AF%BB%E4%BD%A0%E7%9A%84%E7%81%AF%E4%BA%AE%E8%BF%99%E4%B9%88-%E8%B5%B0%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84%E4%B9%8C%E6%89%98%E9%82%A6/ -&lt;p align=&#34;left&#34;&gt;
  军训期间闲着无聊时,决定读一些&amp;ldquo;杂书&amp;rdquo;，其中有一本叫《你的灯亮着么?》的小册子，刚读完不久，趁着今晚休息的时间作以记录。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  &lt;strong&gt;1)&lt;/strong&gt;&lt;strong&gt;动手解决问题前，好好想想问题的来源。2)如何从各个角度看待问题，找到其真正所在。3)为什么不要把人们的解决方法误以为是问题的定义，更不要把某个问题的解决方法误认为是问题的定义，特别是整个解决方法是你自己所使用的。4)永远不要肯定你已经有了一个正确的定义，即使是在问题好像已经解决之后。5)每一种解决方法都会带来新的问题。6)问题最难处理的部分恰恰是去意识到它们的存在。7)在理解问题前，至少要做好准别接受三种可能的出错情况。8)或许还可以改变问题的表述来获得不同的解决方法。9)当你沉迷于寻找问题的定义和解决方法时，不要忘记随时都回头看看，看看自己是不是已经迷路了&amp;hellip;。10)当别人能很好的解决自己的问题时，千万不要越俎代庖。11)如果某人能够解决这个问题，但是他们并不会遇到这一问题时，那么你首先要做的就是让他们也感受一下问题。12)不管看上去如何，人们很少知道他们要什么，直到你给了他们所需要东西。13)甚至，事实上，并没有多少人真的希望他们的问题被解决。&lt;/strong&gt;
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  以上摘自书中序言。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  解决问题前，我们自然要先明确问题，比如问题的对象，问题的内容等等，虽然问题本身并不会有一个通俗简单的定义。但是书中的一种说法确实让人耳目一新&amp;#8212;-&amp;ldquo;&lt;strong&gt;问题就是你所期望的东西和你体验的东西之间的差别&lt;/strong&gt;&amp;rdquo;。对问题的定义是非常重要的―――同样是具有风险的，很多人在问题的定义中徘徊，因为他们不愿承担定义失误的风险。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  作为一个问题的解决者，为了定义一个问题（当然，它并不唯一），我们可以利用经典的分治算法把一个问题变为一系列的问题。为了实现这一转变，我们需要去回答另外一些问题&amp;#8212;比如&amp;ldquo;谁有问题&amp;rdquo;&amp;ldquo;问题的本质是什么&amp;rdquo;&amp;ldquo;问题是谁引起的&amp;rdquo;等等。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  当我们做出了一个比较适合的定义后，我们就可以着手去解决它。由于&amp;ldquo;问题就是你所期望的东西和你体验的东西之间的差别&amp;rdquo;，我们可以从两个方面入手&amp;#8212;-&lt;strong&gt;要么改变期望，要么改变体验&lt;/strong&gt;。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  要改变体验，有很多种方法，书中举例说&amp;ldquo;很多人觉得等待电梯的时间太久&amp;rdquo;―――&amp;ldquo;那么我们的期望的就是更加快速有效的乘坐电梯，体验则是漫长的等待&amp;rdquo;，而解决方法是―――&amp;ldquo;在等待电梯的拐角放上一面镜子&amp;rdquo;――――&amp;ldquo;对着镜子整理衣着减少了人们体验到的时间&amp;rdquo;。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  你从例子中体验到了什么?我悟到的是&amp;ldquo;&lt;strong&gt;体验!=(不等于)现实&lt;/strong&gt;&amp;rdquo;，我们可以在不对现实做出任何改变的同时，用某种手段改变人们的体验。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  但是在解决这一问题后是什么呢?&amp;#8212;-新的问题&amp;#8212;有人在镜子上乱涂乱画！我们的问题解决者不得不继续想办法去解决它。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  &lt;strong&gt;如果你想找到一个问题的解决方法，试试&amp;ldquo;让情况变得更糟&amp;rdquo;&lt;/strong&gt;。基于这个原则，问题解决者把在镜子上涂画变成了一种娱乐的活动&amp;#8212;效果是一样的，人们不会觉得电梯来得太慢了&amp;#8212;他们甚至觉得来得太快了，不是么？
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  在结束这一章时，书中继续了那个很有趣的电梯的故事&amp;#8212;&amp;ldquo;在他们讨论解决问题时，曾经用说笑的口气提出过偷取隔壁大楼电梯使用时间的方法，但是被否决了。后来问题解决者发现隔壁大楼是一座百货商场，而且商场最近生意还不怎么样&amp;#8212;他们巴不得有人去偷取他们的电梯时间呢！&amp;rdquo;文中的结论是&amp;ldquo;对那些没有幽默感的人，帮他们解决问题简直就是自寻烦恼&amp;rdquo;（因为他对这个说笑口气提出的解决方案给予了严肃的批评），我觉得，这告诉我们，&lt;strong&gt;很多方案，我们并不能只从印象和表面去判断他是否可行&amp;#8212;-因为那并不可靠。&lt;/strong&gt;
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  然后是一个新的故事&amp;#8212;-在这里不对那个故事进行复述了，我觉得这个故事中最重要的结论是&amp;ldquo;&lt;strong&gt;不要把他们的解决方法误认为是问题的定义&lt;/strong&gt;&amp;rdquo;即是说，我们要自己去了解问题，而不要从别人那里&amp;#8212;尤其是他们的解决方案那里得到问题的答案。很多时候我们试图从别人那里去得到问题的定义，但是那永远是局部的，这和我们在做题做不出时，会去重读题目一样&amp;#8212;最原始的资料，虽然最难以使用，但却又是最为有效的。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  另外一个结论是：&lt;strong&gt;如果你太轻易地解决了他们的问题，他们永远都不会相信你真的解决了他们的问题。&lt;/strong&gt;
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  人总是过于自信的，这使他们不愿承认自己错误的估计了一个问题的难度。这使得我们有时为了解决一个问题，会浪费比解决问题更多的时间去说服哪些人&amp;#8212;&amp;#8211;为了避免这一点，我们必须在适当的时候承认自己的愚昧和无知。当然，倒过来想，绝大多数问题可以是简单的，只是我们用错了方法，走错了方向。仅此而已。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  在下一个故事中，再次强调了以下的事实：
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  &lt;strong&gt;每一种解决问题的方法都会到来新的问题。我们永远都不能消灭问题。问题、解决问题的方法和新的问题编织成一条无穷无尽的锁链。在解决一个问题的时候，要找出至少三个可能出现的新问题，否则说明我们对于当前问题的理解还不够透彻。&lt;/strong&gt;
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  另外：&lt;strong&gt;问题最难以处理的部分恰恰是去意识到它们的存在。&lt;/strong&gt;如果我们能够意识到问题的存在，那么很多问题是很容易解决的。一个典型的例子是交通限速与交通事故的关系。当能源危机使美国限速减低到55英里时，交通事故大量减少。但是在这以前呢？我们常把原因归因与酒后驾车等问题,根本没有人意识到他们习以为常的交通限速根本就不合理！这是因为我们思维中的惯性的存在。因此，换一个身份进行思考，（孩子，外国人等等）也许你会对问题有一个全新的解读。因为很多我们习以为常的东西其实并不合理，或者说并不完美。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  这也就代入了&amp;ldquo;问题的表述&amp;rdquo;的问题，不同的问题表述可以给我们不同的解决方案，同样会带来不同的新的问题。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  &amp;nbsp;只要我们记得对自己提问：&amp;ldquo;&lt;strong&gt;我们要怎样改变问题的表述才能获得不同的解决方法？&lt;/strong&gt;&amp;rdquo;也许我们就能得到不同表述与答案。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  一个简单的例子是一个简单的圆。我们可以问&amp;ldquo;这个物体是什么?&amp;rdquo;，也可以问&amp;ldquo;这个常见的物体什么?&amp;rdquo;&amp;ldquo;这个不常见的物体是什么?&amp;rdquo;你的答案一定会大不一样吧。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  这里我又想到了一个加鸡蛋的故事：&amp;ldquo;您要加鸡蛋么？&amp;rdquo;&amp;ldquo;您要加一个还是两个鸡蛋？&amp;rdquo;这样提问的两家商店可以有着完全不同的营业额。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  提问的内容与方法确实可以制约到人的思维，进而控制了我们的答案。
&lt;/p&gt;
&lt;p&gt;这其实是一种文字游戏。&lt;/p&gt;
&lt;p&gt;有时我们可以利用它，有时我们却要减少文字引起的不确定性，因此，一旦你用文字来表述一个问题，请仔细推敲这些文字以使这种表述在每个人的头脑中都是一个意思。&lt;/p&gt;
&lt;p&gt;    另外，由于问题中存在的种种陷阱**：**&lt;strong&gt;当你在寻找问题定义的道路上疲倦地游荡时，不要忘记随时都回头看看，看看你是不是已经迷路了。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  又是新的故事。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  如果一些人产生了问题，你最好不要随便的插干涉它&amp;#8212;&amp;ldquo;&lt;strong&gt;当别人能够很好地解决自己问题的时候，千万不要越俎代庖。&lt;/strong&gt;&amp;rdquo;因为外力的入侵或许会使问题产生一些我们事先没有想到的变化&amp;#8212;-比如引入新的变量，改变问题的性质等等。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  如果这是他们的麻烦，就让它成为他们的麻烦吧。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  &amp;nbsp;&amp;nbsp; &amp;nbsp;但是当你无法解决你所解决的问题而需要寻求帮助时，你也许会发现有人可以轻易的解决它。你要如何寻找帮助呢?威逼和利诱都不是最好的选择&amp;#8212;-&lt;strong&gt;你只需要让他也感受到这一问题的存在。&lt;/strong&gt;（当然，这不是永远有效的，因为也许那个人根本就不在乎，或者他会认为你是在给他捣乱！）
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  如果你用尽方法都行不通的话，&lt;strong&gt;为什么不试试指责你自己呢&lt;/strong&gt;？人们倾向于在别人身上寻找问题，确不会降低自己的期望。还记得我们对问题的定义么&amp;ldquo;问题其实就是你期望的东西和你体验的东西之间的差别&amp;rdquo;除了改变体验外，降低期望同样是一种方法&amp;#8212;-虽然你并不喜欢。但是事实是，很多问题的根源在你自己身上。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  不得不提的是书中最经典的一个例子:在一个隧道的入口处有一个照牌&amp;ldquo;警告：前有隧道请打开车头灯&amp;rdquo;，那么隧道的出口呢？&amp;ldquo;请关灯？&amp;rdquo;如果是晚上呢？也许我们可以用非常麻烦的语法分析各种情况写出一个完美的招牌，但是谁会去读它？最简单的方法是&amp;ldquo;如果这是他的问题，把问题留给他好了&amp;rdquo;&amp;#8212;简单的在牌子上写上&amp;ldquo;&lt;strong&gt;你的灯亮这么&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&amp;rdquo;&amp;#8212;我们没有必要为所有人解决一个对每个人都很简单，组合起来确又非常复杂的问题，不是么？
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  最后，书中讨论了一个很奇怪的问题&amp;ldquo;我们真的想解决问题么？&amp;rdquo;虽然很奇怪，但是这种情况确实经常出现。也许你只是在享受问题解决过程的乐趣，也许你解决问题是为了否定它,谁知道呢?
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  最后的最后，是书中的最后说明的一句话：
&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; ****“首先，对自己要真诚。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt; &lt;strong&gt;“&lt;strong&gt;&lt;strong&gt;This above all&lt;/strong&gt;&lt;/strong&gt;，&lt;/strong&gt; &lt;strong&gt;to thine own self be true&lt;/strong&gt;**。”**&lt;/p&gt;
&lt;p&gt;    在解决和定义一个问题前：“道德是最为重要的”&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  &amp;nbsp;
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  &amp;nbsp;&amp;nbsp;&amp;nbsp; 虽然文章已经结束了，我还是想把书中一个很有趣的问题及解决与大家分享，这来自书的序篇。
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  序篇
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  问题：没有人会阅读序言
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  解决方法：把序言称为第一章
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  解决方法带来的新问题：第一章是单调沉闷的
&lt;/p&gt;
&lt;p align=&#34;left&#34;&gt;
  再次解决：把第一章扔了，再把第二章称为第一章
&lt;/p&gt;
- https://sword865.github.io/posts/archives/2009-08-25-%E8%AF%BB%E4%BD%A0%E7%9A%84%E7%81%AF%E4%BA%AE%E8%BF%99%E4%B9%88-%E8%B5%B0%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84%E4%B9%8C%E6%89%98%E9%82%A6/ - Copyright (c) 2015. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>ACM暑假集训总结</title>
        <link>https://sword865.github.io/posts/archives/2009-08-19-acm%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/</link>
        <pubDate>Wed, 19 Aug 2009 00:00:00 +0000</pubDate>
        
        <guid>https://sword865.github.io/posts/archives/2009-08-19-acm%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/</guid>
        <description>悟剑阁 https://sword865.github.io/posts/archives/2009-08-19-acm%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/ -&lt;p&gt;ACM的暑假集训结束了，趁着军训还没开始，对整个暑假接触到的东西作了一个总结，因为刚参加ACM不久，所以内容大都比较基础吧，文章中提到了些参考资料，如果需要的话，请留下邮箱。&lt;/p&gt;
&lt;p&gt;目录&lt;br&gt;
1)数据结构&lt;br&gt;
 1.并查集&lt;br&gt;
 2.高精度数&lt;br&gt;
 3.线段树&lt;br&gt;
 4.字典树&amp;lt;未完成&amp;gt;&lt;br&gt;
2)常用算法&lt;br&gt;
 1.递推&lt;br&gt;
 2.动态规划&lt;br&gt;
 3.贪心&lt;br&gt;
 4.搜索&lt;br&gt;
3)图论部分
 1.2-SAT问题&lt;br&gt;
 2.差分约束系统&lt;br&gt;
 3.二分图&lt;br&gt;
 4.最短路(SPFA,Dijkstra)&lt;br&gt;
 5.欧拉回路&amp;lt;未完成&amp;gt;&lt;br&gt;
 6.最优比率生成树&lt;br&gt;
 7.关键路径&lt;br&gt;
 8.网络流(流的算法/应用)&lt;br&gt;
     最大流算法(3种)&lt;br&gt;
     最小费用最大流算法&lt;br&gt;
     图的连通性（最小点割集）&amp;lt;未完成&amp;gt;&lt;br&gt;
     混合欧拉回路&lt;br&gt;
 9.其他图论相关问题算法:&lt;br&gt;
     K短路  &lt;br&gt;
     图的单向连通（包括2次DFS缩点） &lt;br&gt;
4)其他 &lt;br&gt;
 1.计算几何&lt;br&gt;
 2.数学(数论,组合数学,数值计算) &lt;br&gt;
5)附录&lt;br&gt;
 1.A*算法&lt;br&gt;
 2.位运算之格雷码：&lt;br&gt;
 3.线性同余方程&lt;/p&gt;
&lt;h2 id=&#34;一数据结构&#34;&gt;一．数据结构：&lt;/h2&gt;
&lt;h3 id=&#34;1并查集&#34;&gt;1.并查集.&lt;/h3&gt;
&lt;p&gt;用于实现合并与查找两种操作的数据结构.&lt;br&gt;
实现方法:线形数组,有根树.&lt;br&gt;
优化:&lt;br&gt;
把深度小的树合并到深度大的树,深度相等时任选一棵树,既max(h1,h2), if h1&amp;lt;&amp;gt;h2. / h1+1, if h1=h2.&lt;br&gt;
合并操作时的路径压缩.&lt;br&gt;
并查集的偏移向量:&lt;br&gt;
并查集的偏移向量属于并查集的变形，只要适用于集合数目较少，或是固定的并查集类型。 &lt;br&gt;
增加一个offset字段,表示元素相对根的偏移量.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在find函数中计算偏移量
int findset ( int x )
{
    int t ;
    if ( father [ x ] == x ) return x ;
    else t = findset( father [ x ] ) ;
    offset [ x ] = ( offset [ x ] + offset [ father [ x ] ] ) % DEPTH ;//DEPTH表示几个状态量
    //如果1182中，DEPTH=3；
    father [ x ] = t ;
    return t ; 
}//使用函数递归调用查找父亲在处理上优于循环。
union函数中计算偏移量
void union(int x,int y,int d){
    int fx , fy ;
    fx = find ( x ) ;
    fy = find ( y ) ;
    if ( fx == fy ) return ;
    father [ fx ] = fy ;
    offset [ fx ] = (offset [ y ] - offset[x]+d+3)% 3 ;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2高精度数&#34;&gt;2.高精度数&lt;/h3&gt;
&lt;p&gt;大数的加减乘除&lt;br&gt;
小数的高精度计算参考pku1001&lt;/p&gt;
&lt;h3 id=&#34;3线段树&#34;&gt;3.线段树&lt;/h3&gt;
&lt;p&gt;一棵二叉树，记为T (a,b)，参数a,b表示该节点表示区间[a,b]。区间的长度b-a记为L。递归定义T[a,b].&lt;br&gt;
线段树能在O(logL)的时间内完成一条线段的插入、删除、查找等工作。&lt;br&gt;
应用举例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;求面积:  
    1) 坐标离散化  
    2) 垂直边按x坐标排序  
    3) 从左往右用线段树处理垂直边，累计每个离散x区间长度和线段树长度的乘积  
求周长:  
    1) 坐标离散化  
    2) 垂直边按x坐标排序, 第二关键字为入边优于出边  
    3) 从左往右用线段树处理垂直边，在每个离散点上先加入所有入边,累计线段树长度变化值，再删除所有出边, 累计线段树长度变化值  
    4) 水平边按y坐标排序, 第二关键字为入边优于出边  
    5) 从上往下用线段树处理水平边，在每个离散点上先加入所有入边,累计线段树长度变化值，再删除所有出边, 累计线段树长度变化值  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考资料: segment_tree.pdf&lt;/p&gt;
&lt;h3 id=&#34;4字典树&#34;&gt;4.字典树&lt;/h3&gt;
&lt;p&gt;用于多字符串匹配&lt;br&gt;
加入KMP算法思想成为AC自动机.&lt;/p&gt;
&lt;h2 id=&#34;二常用算法&#34;&gt;二.常用算法&lt;/h2&gt;
&lt;h3 id=&#34;1递推&#34;&gt;1.递推&lt;/h3&gt;
&lt;p&gt;寻找f(n)与f(m)的关系&lt;br&gt;
经典问题:&lt;br&gt;
 约翰夫环的递推公式.&lt;br&gt;
 fib数（矩阵乘快速计算法）&lt;br&gt;
 参考&amp;lt;具体数学&amp;gt;第一章&lt;/p&gt;
&lt;h3 id=&#34;2动态规划&#34;&gt;2.动态规划&lt;/h3&gt;
&lt;p&gt;重叠子问题较多的问题&lt;br&gt;
记录重叠子问题解得解&lt;br&gt;
子状态的确定与状态转移函数.&lt;/p&gt;
&lt;h3 id=&#34;3贪心&#34;&gt;3.贪心&lt;/h3&gt;
&lt;p&gt;在对问题求解时，总是作出在当前看来是最好的选择。也就是说，不从整体上加以考虑，它所作出的仅仅是在某种意义上的局部最优解（是否是全局最优，需要证明）。&lt;br&gt;
注意:若要用贪心算法求解某问题的整体最优解，必须首先证明贪心思想在该问题的应用结果就是最优解！&lt;/p&gt;
&lt;h3 id=&#34;4搜索&#34;&gt;4.搜索&lt;/h3&gt;
&lt;p&gt;广度优先搜索，深度优先搜索。 &lt;br&gt;
双向广度优先搜索&lt;br&gt;
启发试搜索(A*）（详细见附录部分）&lt;br&gt;
搜索的减枝与优化&lt;br&gt;
参考资料: 搜索算法全集.pdf / 搜索.ppt / 启发式搜索.doc&lt;/p&gt;
&lt;h2 id=&#34;三图论部分&#34;&gt;三．图论部分&lt;/h2&gt;
&lt;h3 id=&#34;1-2-sat问题&#34;&gt;1. 2-SAT问题&lt;/h3&gt;
&lt;p&gt;设 $B=\{b_1,b_2…b_n\}$ 为一个有限布尔集变量，$\hat{B}=\{b_1,b_2,…b_n,!b_1,!b_2,…，!b_n\}$.(!为取反)&lt;/p&gt;
&lt;p&gt;设$B&amp;rsquo;$为$\hat{B}$的非空子集,定义$\vee B&amp;rsquo;=\vee_{b\in B&amp;rsquo;}b$，对于给定的$B_1’,B_2’…B_m’\subset B’$，求B，使得等式: $(\vee B_1&amp;rsquo;)\wedge(\vee B_2&amp;rsquo;)\wedge&amp;hellip;\wedge(\vee B_m&amp;rsquo;)=1$ 成立，称为适应性问题，简称SAT。&lt;br&gt;
当对给定的$\{B_m&amp;rsquo;\}$，如果$max\{|B_x&amp;rsquo;|\}=k$,我们就把这个问题称为k-适定性问题，简称k-SAT。&lt;br&gt;
可以证明，当时，k-SAT是NP完全的。&lt;br&gt;
2-SAT解法：构图法，对每个bx,!bx,都对应图中一个节点，共2n个节点，每个逻辑关系表示一条边，如pku2723：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1）对于一组相互排斥的钥匙 x，y，只能选一把，所以x &amp;amp;y==0．即 x —&amp;gt; ~y ， y —&amp;gt; ~x.。  
2）对于门，因为必须打开所以 x|y==1.　即 ~x—&amp;gt; y , ~y—&amp;gt; x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考资料：sat2_sjtu_zhaoshuang.pdf　/　2-SAT.PPT&lt;/p&gt;
&lt;h3 id=&#34;2差分约束系统&#34;&gt;2.差分约束系统&lt;/h3&gt;
&lt;p&gt;比如有这样一组不等式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;X1 - X2 &amp;lt;= 0
X1 - X5 &amp;lt;= -1
X2 - X5 &amp;lt;= 1
X3 - X1 &amp;lt;= 5
X4 - X1 &amp;lt;= 4
X4 - X3 &amp;lt;= -1
X5 - X3 &amp;lt;= -3
X5 -X4 &amp;lt;= -3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全都是两个未知数的差小于等于某个常数（大于等于也可以，因为左右乘以-1就可以化成小于等于）。这样的不等式组就称作差分约束系统。&lt;br&gt;
构图法:利用最短路中的三角不等式,即:d(v)-d(u)&amp;lt;=w(u,v),每个未知数对应一个顶点,每个不等式对应一条边,(将xi-xj&amp;lt;=c变为权值为c的边vi-&amp;gt;vj),最后在图上求一次最短路,则所有不等式都会满足,
图中的源点可以任意选择.也可建立一个x0作为源点.x0的相关性质可以任意设置.&lt;br&gt;
参考资料: 差分约束系统.doc&lt;/p&gt;
&lt;h3 id=&#34;3二分图&#34;&gt;3.二分图&lt;/h3&gt;
&lt;p&gt;二分图又称作二部图，是图论中的一种特殊模型。 &lt;br&gt;
设G=(V,{R})是一个无向图。如顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属两个不同的子集。则称图G为二分图。 &lt;br&gt;
给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。 &lt;br&gt;
选择这样的边数最大的子集称为图的最大匹配问题(maximal matching problem)
如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。&lt;/p&gt;
&lt;h4 id=&#34;匈牙利算法&#34;&gt;匈牙利算法：&lt;/h4&gt;
&lt;p&gt;不断寻找增广路经，其核心是DFS。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool path (int u)
{
    sx [u] = true;
    for (int v = 0; v &amp;lt; n; v ++){
        if (!sy [v] &amp;amp;&amp;amp; lx[u] + ly [v] == weight [u] [v])
        {
            sy [v] = true;
            if (match [v] == -1 || path (match [v]))
            {
                match [v] = u;
                return true;
            }
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对每个顶点求一次增广路经即可。（可以证明，如果某次从某个顶点出发可以找到一条增广路经，则以后不可能再该定点找到增光路经，而如果某个定点出发找到了增广路经，则该店就成为路经中的点）
注：如果边上带权的话，找出权和最大的匹配叫做求最佳匹配。&lt;/p&gt;
&lt;h4 id=&#34;km算法&#34;&gt;KM算法：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;设M是一个带权完全二分图G的一个完备匹配，给每个顶点一个可行顶标(第i个x顶点的可行标用lx[i]表示，第j个y顶点的可行标用ly[j]表示)，如果对所有的边(i,j) in G,都有lx[i]+ly[j]&amp;gt;=w[i,j]成立(w[i,j]表示边的权)，且对所有的边(i,j) in M,都有lx[i]+ly[j]=w[i,j]成立，则M是图G的一个最佳匹配。&lt;br&gt;
步骤： &lt;br&gt;
(1)初始化可行顶标的值（l(x) =max w(x,y),l(y) = 0&lt;br&gt;
(2)用匈牙利算法寻找完备匹配&lt;br&gt;
(3)若未找到完备匹配则修改可行顶标的值（根据最后一次不成功的寻找交错路的DFS，取所有i被访问到而j没被访问到的边(i,j)的lx[i]+ly[j]-w[i][j]的最小值d。将交错树中的所有左端点的顶标减小d，右端点的顶标增加d。）&lt;br&gt;
(4)重复(2)(3)直到找到相等子图的完备匹配为止&lt;br&gt;
优化：设slack[j]表示右边的点j的所有不在导出子图的边对应的lx[i]+ly[j]-w[i][j]的最小值，在find过程中，若某条边不在导出子图中就用它对相应的slack值进行更新。然后求只要用O(N)的时间找到slack中的最小值就可以用其调整权值了。（代码参考code/图/KM2）&lt;br&gt;
复杂度：优化前O（N3），优化后O(N2)&lt;br&gt;
参考资料：二分图匹配.ppt&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4最短路spfadijkstra&#34;&gt;4.最短路(SPFA,Dijkstra)&lt;/h3&gt;
&lt;p&gt;SPFA算法可以处理负边。dij算法中每条边的最短路径值仅会受到在层次图中层次小于它的点影响，确定后不会改变，SPFA没有这些特点，所以可以通过多次迭代确定最短路。&lt;br&gt;
参考资料：SPFA与Dijkstra,doc&lt;/p&gt;
&lt;h3 id=&#34;5欧拉回路&#34;&gt;5.欧拉回路&lt;/h3&gt;
&lt;p&gt;Fleury算法&lt;br&gt;
　（1）任取v0∈V(G)，令P0=v0.&lt;br&gt;
　（2）设Pi=v0e1v1e2…eivi已经行遍，按下面方法来从E(G)-{e1,e2,..,ei}中选取ei+1：&lt;br&gt;
　　　（a）ei+1与vi相关联；&lt;br&gt;
　　　（b）除非无别的边可供行遍，否则ei+1不应该为Gi=G-{e1,e2,&amp;hellip;,ei}中的桥。&lt;br&gt;
　（3）当（2）不能再进行时，算法停止。&lt;br&gt;
连环法（未完成）&lt;/p&gt;
&lt;h3 id=&#34;6最优比率生成树&#34;&gt;6.最优比率生成树&lt;/h3&gt;
&lt;p&gt;概念：&lt;br&gt;
有带权图G, 对于图中每条边e[i], 都有c[i](收入)和d[i](花费), 我们要求的是一棵生成树T, 它使得有：∑(c[i]) / ∑(d[i]), i∈T最大(或最小).&lt;br&gt;
0-1分数规划解法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;r=cx/dx (c,d,x都是向量) ,求最小的r,设为r*  
z=cx-l*dx(1)把它的最小值记为z(l),对一个确定的l解释以lc-d为权的最小生成树.  
若z(r*)&amp;lt;0;存在一组x使r*&amp;gt;cx/dx,与r*是cx/dx的最小值矛盾.  
若z(r*)&amp;gt;0,不可能,因为有一组x*使r*=cx*/dx*,把这组x代入(1)得0,必有最小值&amp;lt;=0  
所以z(r*) == 0;
z(l)递减  
按上述二分查找计算  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考资料：最优比率生成树.doc&lt;/p&gt;
&lt;h3 id=&#34;7关键路径&#34;&gt;7.关键路径&lt;/h3&gt;
&lt;p&gt;整个工程完成的时间为：从有向图的源点到汇点的最长路径。&lt;br&gt;
“关键活动“指的是：该弧上的权值增加 将使有向图上的最长路径的长度增加。 &lt;br&gt;
解法：DP递推&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“事件(顶点)“的最早发生时间 ve(j) = 从源点到顶点j的最长路径长度;  
“事件(顶点)“的最迟发生时间 vl(k) = 从顶点k到汇点的最短路径长度;  
假设第 i 条弧为   
则 对第 i 项活动言  
“活动(弧)“的 最早开始时间 e(i) = ve(j);  
“活动(弧)“的 最迟开始时间 l(i) = vl(k)-dut();  
状态转移方程  
    ve(k) = Max{ve(j) + dut()}  
    vl(j) = Min{vl(k) - dut()}  
解：  
    e(i) = ve(j);  
    l(i) = vl(k) - dut();  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8网络流流的算法应用&#34;&gt;8.网络流(流的算法/应用)&lt;/h3&gt;
&lt;p&gt;最大流算法(3种)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本最大流算法 &amp;mdash; Edmonds-Karp算法O(VE2)&lt;br&gt;
　　通过DFS每次寻找最短的增广路径增流。核心BFS。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dinic算法 O(V2E) BFS建立层次网络，DFS找增广路经增幅． &lt;br&gt;
　　BFS 寻找终点太慢，而 DFS 又不能保证找到最短路径。1970年 Dinic 提出一种思想，结合了 BFS 与 DFS 的优势，采用构造分层网络的方法可以较快找到最短增广路，此算法又称为阻塞流算法 (Blocking Flow Algorithm)。&lt;br&gt;
　　首先定义分层网络 AN(f)。在残量网络中从源点 s 起始进行 BFS，这样每个顶点在 BFS 树中会得到一个距源点s 的距离 d，如 d(s) = 0，直接从 s 出发可到达的点距离为1，下一层距离为2&amp;hellip;。称所有具有相同距离的顶点位于同一层，在分层网络中，只保留满足条件 d(i) + 1 = d(j) 的边，这样在分层网络中的任意路径就成为到达此顶点的最短路径。&lt;br&gt;
　　Dinic 算法每次用一遍 BFS 构建分层网络 AN(f)，然后在 AN(f) 中一遍 DFS 找到所有到终点 t 的路径增广；之后重新构造 AN(f)，若终点 t 不在 AN(f) 中则算法结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ISAP O(VE2) &lt;br&gt;
　　通常的SAP类算法在寻找增广路时总要先进行 BFS，BFS 的最坏情况下复杂度为 O(E)    ，这样使得普通SAP类算法最坏情况下时间复杂度达到了 O(VE2)。为了避免这种情况，Ahuja和Orlin 在1987年提出了Improved SAP算法，它充分利用了距离标号的作用，每次发现顶点无出弧时不是像 Dinic 算法那样到最后进行 BFS，而是就地对顶点距离重标号，这样相当于在遍历的同时顺便构建了新的分层网络，每轮寻找之间不必再插 入全图的BFS操作，极大提高了运行效率。国内一般把这个算法称为SAP，显然这是不准确的，毕竟从字面意思上来看 E-K 和 Dinic 都属于 SAP，我还是习惯称为 ISAP 或改进的 SAP 算法。 &lt;br&gt;
　　与 Dinic算法不同，ISAP中的距离标号是每个顶点到达终点t的距离。同样也不需显式构造分层网络只要保存每个顶点的距离标号即可。程序开始时用一个反向BFS初始化所有顶点的距离标号，之后从源点开始，进行如下三种操作：&lt;/p&gt;
&lt;p&gt;(1)当前顶点i为终点时增广
(2)当前顶点有满足 dist[i] = dist[j]+1的出弧时前进
(3) 当前顶点无满足条件的出弧时重标号并回退一步。整个循环当源点s的距离标号dist[s] &amp;gt;= n 时结束。 &lt;br&gt;
注：对i点的重标号操作可概括为：dist[i] = 1 + min{dist[j] : (i,j)属于残量网络Gf}。 &lt;br&gt;
实现代码见code/图/最大流多种实现-1273 &lt;br&gt;
*最小费用最大流算法：每次增广所有路径中单位费用和最小的一条即可。 &lt;br&gt;
*图的连通性（最小点割集） &lt;br&gt;
*构图求最大流：(未完成)  &lt;br&gt;
*混合欧拉回路  &lt;br&gt;
*构图求最大流：(关键:欧拉回路存在的条件是每个个点的入度等于出度) &lt;br&gt;
　　把该图的无向边随便定向，计算每个点的入度和出度。如果有某个点出入度之差为奇数，那么肯定不存在欧拉回路。因为欧拉回路要求每点入度=出度，也就是总度数为偶数，存在奇数度点必不能有欧拉回路。好了，现在每个点入度和出度之差均为偶数。那么将这个偶数除以2，得x。也就是说，对于每一个点，只要将x条边改变方向（入&amp;gt;出就是变入，出&amp;gt;入就是变出），就能保证出=入。如果每个点都是出=入，那么很明显，该图就存在欧拉回路。&lt;br&gt;
　　现在的问题就变成了：我该改变哪些边，可以让每个点出=入？如下构造网络流模型： &lt;br&gt;
　　首先，有向边是不能改变方向的，要之无用，删。一开始不是把无向边定向了吗？定的是什么向，就把网络构建成什么样，边长容量上限1。另新建s和t。对于入 &amp;gt; 出的点u，连接边(u, t)、容量为x，对于出&amp;gt;入的点v，连接边(s, v)，容量为x（注意对不同的点x不同）。之后，察看是否有满流的分配。有就是能有欧拉回路，没有就是没有。欧拉回路是哪个？察看流值分配，将所有流量非0（上限是1，流值不是0就是1）的边反向，就能得到每点入度 = 出度的欧拉图。由于是满流，所以每个入出的点，都有x条边进来，将这些进来的边反向，OK，入=出了。对于出&amp;gt; 入的点亦然。那么，没和s、t连接的点怎么办？和s连接的条件是出&amp;gt;入，和t连接的条件是入&amp;lt;出，那么这个既没和s也没和t连接的点，自然早在开始就已经满足入=出了。那么在网络流过程中，这些点属于“中间点”。我们知道中间点流量不允许有累积的，这样，进去多少就出来多少，反向之后，自然仍保持平衡。  &lt;br&gt;
代码：code图1637&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;9其他图论相关问题算法&#34;&gt;9.其他图论相关问题算法:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;K短路    &lt;br&gt;
A*搜索，搜索到终点K次时走的路径函数: &lt;br&gt;
f(x)=h(x)+g(x) h(x)&amp;ndash;点离目标点的距离(估计值) &lt;br&gt;
g(x)&amp;ndash;点离起点的距离（确定值）估计值可用反向dij得到的值代替，也可以跟据情况用其他值估计。 &lt;br&gt;
代码：code图244&lt;/li&gt;
&lt;li&gt;图的单向连通（包括2次DFS缩点） &lt;br&gt;
判断途中任意两点是否存在至少一条通路． &lt;br&gt;
如果把句子“either go from x to y, or from y to x.“改为“both go from x to y, and from y to x.“则题意即为求证图是否为强连通图。求强连通图的方法有很多，最简单的是从点v开始，正向floodfill一遍，反向floodfill一遍，然后其交集即为包含点v的最大强连通子图。 &lt;br&gt;
然而这道题要求判断的是是否为单向连通图，即对于任意两点u,v，要么存在路径从u到v，要么存在路径从v到u。 &lt;br&gt;
首先，强连通图肯定是单向连通图，但是反之不然。 &lt;br&gt;
其次，如果图中不存在任意一对双向连通的点，则该图肯定是有向无环图。考虑该图的拓扑序，则若存在序u&amp;gt;v，必说明存在一条路从u到v。如果上图还是单向连通图，说明任意两点都有序，则由有向无环的性质，该序可以唯一确定。则依该序排序图中所有点，结果必然唯一。即存在一条路，从某个点出发，到另一个点截止，中间经过所有的结点。 &lt;br&gt;
所以，只要把图中所有的最大强连通子图都找出来，并且各自缩为单一点。这样重构的图要么是一个点，要么是有向无环图。后者的话，做一次拓扑排序，只要在某一刻存在两个以上的点入度为0的话就判错；其他情况都判对。 &lt;br&gt;
代码：code图2728 &lt;br&gt;
缩点可参考　code图2443&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;四其他&#34;&gt;四．其他&lt;/h2&gt;
&lt;h3 id=&#34;1计算几何&#34;&gt;1.计算几何&lt;/h3&gt;
&lt;p&gt;注意模板的使用与精度问题   &lt;br&gt;
凸包问题 &lt;br&gt;
直线，点的各种关系的计算 &lt;br&gt;
点乘与叉乘&lt;/p&gt;
&lt;h3 id=&#34;2数学数论组合数学数值计算&#34;&gt;2.数学(数论,组合数学,数值计算)&lt;/h3&gt;
&lt;p&gt;数论：质数问题,分解因素，模预算，中国剩余定理(见附录)，进制转换 &lt;br&gt;
组合数学：容斥定理，雀巢定理，Catalan number &lt;br&gt;
数值计算：二分法(f(x)=0) ,迭代法(g(x)=x)&lt;/p&gt;
&lt;h2 id=&#34;五附录&#34;&gt;五．附录&lt;/h2&gt;
&lt;h3 id=&#34;1a算法&#34;&gt;1.A*算法&lt;/h3&gt;
&lt;p&gt;在启发式搜索中，对于每个状态 x，启发函数 f(x) 通常是这样的形式：   &lt;br&gt;
f(x) = g(x) + h(x) &lt;br&gt;
其中 g(x) 是从初始状态走到 x 所花的代价；h(x) 是从 x 走到目标状态所需要的代价的估计值。&lt;br&gt;
相对于 h(x)，还有一个概念叫h*(x)，表示从x走到目标状态所需要的实际最小代价（当然，这个值有时我们是事先无法知道的）。   &lt;br&gt;
如果在你的启发函数里，能保证 h(x) &amp;lt;= h*(x)，也就是说，你不能高估了从 x     走到目标状态所需要的代价，那就可以说这个搜索是 A* 算法（这里的*，英文就读作 star）。 &lt;br&gt;
A* 算法的特点是，如果存在从初始状态走到目标状态的最小代价的解，那么用 A*     算法搜索时，第一个找到的解就一定是最小代价的。这就是所谓的可采纳（admissible）。 &lt;br&gt;
例:求前 K 短的 可以带环的 路径（的长度） &lt;br&gt;
1.1. 典型的启发式搜索 &lt;br&gt;
设起点为 s；终点为 t；对于一个点 v，dt(v) 表示从 v 走到 t     的最短路径的长度（可以在初始化的时候全都算好）。 &lt;br&gt;
网友 richard 教会了我，可以用最典型的启发式搜索来解这个问题。一个状态 x 表示的是从s走到某个点的一条路径，把这个点记作 x.v，把这条路径的长度记作     x.len。接着，我们可以使用以下启发函数： &lt;br&gt;
g(x) = x.len; h(x) = dt(x.v); &lt;br&gt;
∴ f(x) = g(x) + h(x) = x.len + dt(x.v) &lt;br&gt;
初始状态中， x.v = s； x.len = 0。然后每次让优先队列（所谓的 Open 表）中 f(x)     值最小的状态 x 出队，再跟据图中所有从 x.v 出发的边发展下一层状态，让它们进队列。优先队    列中不存在判重复的问题，因为每个状态所代表的路径肯定是不一样的。 &lt;br&gt;
不难想通，这是一个 A* 算法，因为这里的 h(x) 本身就是 h*(x)，当然满足 h(x) &amp;lt;= h*(x)。因此可以说，在每次出队列的状态 x 中，第一次遇到 x.v == t 时，就找到了从s到t的第一短的路径，它的长度就是f(x)&amp;hellip;第 k 次遇到 x.v == t 时，就找到了从s到t的第k 短的路径。 &lt;br&gt;
&lt;a href=&#34;http://zone.emsky.net/?uid-2-action-viewspace-itemid-118&#34;&gt;http://zone.emsky.net/?uid-2-action-viewspace-itemid-118&lt;/a&gt; A*寻路.&lt;/p&gt;
&lt;h3 id=&#34;2位运算之格雷码&#34;&gt;2.位运算之格雷码：&lt;/h3&gt;
&lt;p&gt;这种遍历顺序作为一种编码方式存在，叫做Gray码（写个中文让蜘蛛来抓：格雷码）。它的应用范围很广。比如，n阶的Gray码相当于在n维立方体上的Hamilton回路，因为沿着立方体上的边走一步，n维坐标中只会有一个值改变。再比如，Gray码和Hanoi塔问题等价。Gray码改变的是第几个数，Hanoi塔就该移动哪个盘子。比如，3阶的Gray码每次改变的元素所在位置依次为1-2-1-3-1-2-1，这正好是3阶Hanoi塔每次移动盘子编号。如果我们可以快速求出Gray码的第n个数是多少，我们就可以输出任意步数后Hanoi塔的移动步骤。现在我告诉你，Gray码的第n个数（从0算起）是n xor (n shr 1)，你能想出来这是为什么吗？先自己想想吧。 &lt;br&gt;
下面我们把二进制数和Gray码都写在下面，可以看到左边的数异或自身右移的结果就等于右边的数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;二进制数 Gray码    
000 000    
001 001    
010 011    
011 010    
100 110    
101 111    
110 101    
111 100    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从二进制数的角度看，“镜像“位置上的数即是对原数进行not运算后的结果。比如，第3个数010和倒数第    3个数101的每一位都正好相反。假设这两个数分别为x和y，那么x xor (x shr 1)和y xor (y shr 1)的结果只有一点不同：后者的首位是1，前者的首位是0。而这正好是Gray码的生成方法。这就说明了，Gray码的第n个数确实是n xor(n shr 1)。 &lt;br&gt;
今年四月份mashuo给我看了这道题，是二维意义上的Gray码。题目大意是说，把0到2^(n+m)-1的数写成2^n*2^m的矩阵，使得位置相邻两数的二进制表示只有一位之差。答案其实很简单，所有数都是由m位的Gray码和n位Gray码拼接而成，需要用左移操作和or运算完成。完整的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x,y,m,n,u:longint;    
begin    
    readln(m,n);    
    for x:=0 to 1 shl m-1 do begin    
    u:=(x xor (x shr 1)) shl n; //输出数的左边是一个m位的Gray码    
    for y:=0 to 1 shl n-1 do    
        write(u or (y xor (y shr 1)),&amp;amp;#8217; &amp;amp;#8216;); //并上一个n位Gray码    
        writeln;    
    end;    
end.    
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3线性同余方程&#34;&gt;3.线性同余方程&lt;/h3&gt;
&lt;p&gt;问题简单来说就是 a = ai (mod ni) 求未知数a。 &lt;br&gt;
以下小结略去证明, 只是对定理作了必要的解释, 要了解相关定理,可查阅数论资料. &lt;br&gt;
中国余数定理: &lt;br&gt;
设 n=n1&lt;em&gt;n2&amp;hellip;nk, 其中因子两两互质.有: a&amp;mdash;(a1,a2,&amp;hellip;,ak), 其中ai = a mod ni, 则a和(a1,a2,&amp;hellip;,ak)关系是一一对应的.就是说可以由 a求出(a1,a2,&amp;hellip;,ak),也可以由(a1,a2,&amp;hellip;,ak)求出a。 &lt;br&gt;
推论1:   &lt;br&gt;
对于 a=ai (mod ni) 的同余方程,有唯一解 &lt;br&gt;
下面说说由(a1, a2, &amp;hellip;, ak)求a的方法: &lt;br&gt;
定义 mi = n1*n2*&amp;hellip;nk / ni; ci = mi(mf mod ni); 其中 mi&lt;/em&gt;mf mod ni = 1; &lt;br&gt;
则 a = (a1*c1+a2*c2+&amp;hellip;+ak&lt;em&gt;ck) (mod n) (注:由此等式可求a%n, 当n很大时) &lt;br&gt;
中国剩余定理关键是mf的求法,如果理解了扩展欧几里得 ax+by=d, 就可以想到: &lt;br&gt;
mi*mf mod ni = 1 =&amp;gt; mi*mf+ni&lt;/em&gt;y=1; &lt;br&gt;
代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int MAXN = 100;    
int nn, a[MAXN], n[MAXN];    
int egcd(int a, int b, int &amp;amp;x, int &amp;amp;y) {    
    int d;    
    if (b == 0) {     
        x = 1; y = 0;    
        return a;    
    } else {    
        d = egcd(b, a%b, y, x);    
        y -= a/b*x;    
        return d;    
    }    
}    
int lmes() {    
    int i, tm=1, mf, y, ret=0, m;    
    for (i=0; i&amp;lt;nn; i++) tm *= n[i];    
        for (i=0; i&amp;lt;nn; i++) {    
            m = tm/n[i];    
            egcd(m, n[i], &amp;amp;mf, &amp;amp;y);    
            ret += (a[i]*m*(mf%n[i]))%tm;    
        }    
    return (ret+tm)%tm;    
}    
int main() {    
    a[0] = 4; a[1] = 5;     
    n[0] = 5; n[1] = 11;    
    nn = 2;    
    printf(“%d“, lmes());    
    return 0;    
}    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附录2: &lt;br&gt;
求最小点基 &amp;lt;图论算法与程序设计&amp;gt; P49 &lt;br&gt;
求点连通度 &amp;lt;图论算法与程序设计&amp;gt; P102 &lt;br&gt;
附：北邮ACM50题 &lt;br&gt;
第一类 动态规划 (至少6题，2479 and 2593必做) &lt;br&gt;
2479 and 2593 1015 1042 (也可贪心) 1141 1050 1080 1221 1260 2411 (稍难) 1276 &lt;br&gt;
第二类 搜索 (至少4题) &lt;br&gt;
1011 1033 1129 2049 2056 2488 2492 (稍难，也可并查集) &lt;br&gt;
第三类 贪心 (至少2题) &lt;br&gt;
1065 2054 (难) 1521 2709 &lt;br&gt;
第四类 最短路 (至少3题) &lt;br&gt;
1062 1125 1797 2253 2679 Bellman-Ford (难) &lt;br&gt;
第五类 最小生成树 (至少2题, 而且 Prim 和 Kruskal 至少各用一次) &lt;br&gt;
1251 1258 1789 2485 &lt;br&gt;
第六类 最大流 (至少2题) &lt;br&gt;
1087 1459 1149 2516 (最小费用最大流) (难) &lt;br&gt;
第七类 二分图 (至少3题) &lt;br&gt;
1325 1469 2195 (KM 算法或最小费用最大流) (难) 2446 1422 and 2594 &lt;br&gt;
第八类 并查集 (至少2题) &lt;br&gt;
1861 1182 (难) 1308 2524 &lt;br&gt;
第九类 快速查找 (B-Search, Hash and so on) (至少3题) &lt;br&gt;
2503 2513 (+Euler回路的判定) 1035 1200 2002 &lt;br&gt;
第十类 数论 (至少2题) &lt;br&gt;
1061 1142 2262 2407 1811(难) 2447 (难) &lt;br&gt;
第十一类 线段树 (无最少题数要求) &lt;br&gt;
2352 (可用简单方法) 2528 &lt;br&gt;
第十二类 计算几何 (至少2题，1113凸包算法必做) &lt;br&gt;
1113 1292 2148 (难) 2653 1584 &lt;br&gt;
第十三类 高精度 (至少3题，1001必做) &lt;br&gt;
1001 1047 1131 1503 1504 1060 and 1996 (多项式) SCU1002, 1003, 1004 (http://    acm.scu.edu.cn/soj) &lt;br&gt;
第十四类 模拟 (至少5题) &lt;br&gt;
1029 and 1013 1083 and 2028 2234 and 1067 1012 1026 1068 1120 2271 2632 &lt;br&gt;
第十五类 数学 (至少4题) &lt;br&gt;
2249 1023 2506 1079 1019 and 1095 1905 and 1064 (二分)&lt;/p&gt;
&lt;div&gt;    
  &lt;embed id=“lingoes_plugin_object“ width=“0“ height=“0“ type=“application/    lingoes-npruntime-capture-word-plugin“ hidden=“true“ /&gt;    
&lt;/div&gt;
- https://sword865.github.io/posts/archives/2009-08-19-acm%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/ - Copyright (c) 2015. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>有重复组合数</title>
        <link>https://sword865.github.io/posts/archives/2009-04-02-%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%84%E5%90%88%E6%95%B0/</link>
        <pubDate>Thu, 02 Apr 2009 00:00:00 +0000</pubDate>
        
        <guid>https://sword865.github.io/posts/archives/2009-04-02-%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%84%E5%90%88%E6%95%B0/</guid>
        <description>悟剑阁 https://sword865.github.io/posts/archives/2009-04-02-%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%84%E5%90%88%E6%95%B0/ -&lt;p&gt;从n个元素中有重复地取r个，不计顺序，则不同的取法有多少种？&lt;br&gt;
这个问题的答案被称为有重复组合数。结果很简洁，是C(n+r-1,r)。(注：这表示从n+r-1个数中取出r个数的组合数)&lt;br&gt;
【证明1】&lt;br&gt;
我们先把原命题具体化。假设这n个元素就是1&lt;del&gt;n这n个数:       &lt;br&gt;
对于每一种选出来的组合a1，a2，a3，&amp;hellip; ，am，我们要求：a1&amp;lt;=a2&amp;lt;=a3&amp;lt;=&amp;hellip;&amp;lt;=ar，那么最终的目的就是找出这样的a(i)组数。&lt;br&gt;
这里我们构造b1=a1，b2= a2+1，&amp;hellip; ，b(i)= a(i)+(i-1)，&amp;hellip; ，b(r)= a(r)+(r-1)&lt;br&gt;
于是b(i)和a(i)一一对应，即所求a(i)组数对应于b(i)组数&lt;br&gt;
又因为 b1 &amp;lt; b2 &amp;lt; b3 &amp;lt; &amp;hellip; &amp;lt; br 且b(i)取值于1&lt;/del&gt; n+(r-1)&lt;br&gt;
亦即原命题等价于从1~ n+r-1中取得r个不重复排列数&lt;br&gt;
来源：&lt;a href=&#34;http://zhidao.baidu.com/question/16706714.html&#34;&gt;http://zhidao.baidu.com/question/16706714.html&lt;/a&gt;&lt;br&gt;
【证明2】&lt;br&gt;
将n个元素看做n个盒子,r看作r个无区别的球,则相当于:&lt;br&gt;
把r个同样的球放入n个顺次排列的盒子,求不计放球顺序的放法种数&lt;br&gt;
用0表示盒子,1表示球&lt;br&gt;
我们把这n个0和r个1写在一行上。&lt;br&gt;
由于球必须放在盒子中,规定某个0之前,到上一个0为止的1的个数,表示该盒子中装的球数&lt;br&gt;
注意到最后一个数必须是0&lt;br&gt;
所以相当于从前面n+r-1个位置中挑出r个位置放1，其余n-1个位置放0&lt;br&gt;
来源：&lt;a href=&#34;http://pengzhe0302.spaces.live.com/blog/cns!529d86ea9ec40ca2!113.entry&#34;&gt;http://pengzhe0302.spaces.live.com/blog/cns!529d86ea9ec40ca2!113.entry&lt;/a&gt;&lt;/p&gt;
&lt;div&gt;
  &lt;embed id=&#34;lingoes_plugin_object&#34; width=&#34;0&#34; height=&#34;0&#34; type=&#34;application/lingoes-npruntime-capture-word-plugin&#34; hidden=&#34;true&#34; /&gt;
&lt;/div&gt;
- https://sword865.github.io/posts/archives/2009-04-02-%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%84%E5%90%88%E6%95%B0/ - Copyright (c) 2015. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>终于还是开了个blog。。。</title>
        <link>https://sword865.github.io/posts/archives/2009-03-08-%E7%BB%88%E4%BA%8E%E8%BF%98%E6%98%AF%E5%BC%80%E4%BA%86%E4%B8%AAblog/</link>
        <pubDate>Sun, 08 Mar 2009 00:00:00 +0000</pubDate>
        
        <guid>https://sword865.github.io/posts/archives/2009-03-08-%E7%BB%88%E4%BA%8E%E8%BF%98%E6%98%AF%E5%BC%80%E4%BA%86%E4%B8%AAblog/</guid>
        <description>悟剑阁 https://sword865.github.io/posts/archives/2009-03-08-%E7%BB%88%E4%BA%8E%E8%BF%98%E6%98%AF%E5%BC%80%E4%BA%86%E4%B8%AAblog/ -&lt;p&gt;RT&lt;br&gt;
以后常来看看吧&lt;/p&gt;
- https://sword865.github.io/posts/archives/2009-03-08-%E7%BB%88%E4%BA%8E%E8%BF%98%E6%98%AF%E5%BC%80%E4%BA%86%E4%B8%AAblog/ - Copyright (c) 2015. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>编译原理虎书java版本–Chapter 1</title>
        <link>https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/</link>
        <pubDate>Sun, 08 Mar 2009 00:00:00 +0000</pubDate>
        
        <guid>https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/</guid>
        <description>悟剑阁 https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/ -&lt;p&gt;Count.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class  Count
{
    int resolveStm(Stm stm){
        int temp1=0,temp2=0;
        if(stm.kind==1){
            temp1=resolveStm(((CompoundStm)stm).stm1);
            temp2=resolveStm(((CompoundStm)stm).stm2);
            return temp1&amp;gt;temp2? temp1:temp2;
        }else if(stm.kind==2){
            return resolveExp(((AssignStm)stm).exp);
        }else if (stm.kind==3){
            return countExpInExpList(((PrintStm)stm).exps);
        }else{
            return 0;
        }
    }
    int countExpInExpList(ExpList expList){
        if(expList.kind==1){
            return 1;
        }else if(expList.kind==2){
            return 1+countExpInExpList(((PairExpList)expList).tail);
        }else{
            return 0;
        }
    }
    int resolveExp(Exp exp){
        int temp1,temp2;
        if(exp.kind==1){
            return 0;
        }else if(exp.kind==2){
            return 0;
        }else if(exp.kind==3){
            temp1 = resolveExp(((OpExp)exp).left);
            temp2 = resolveExp(((OpExp)exp).right);
            return temp1&amp;gt;temp2?temp1:temp2;
        }else if(exp.kind==4){
            temp1=resolveStm(((EseqExp)exp).stm);
            temp2=resolveExp(((EseqExp)exp).exp);
            return temp1&amp;gt;temp2?temp1:temp2;
        }else{
            return 0;
        }
    }
    int resolveExpList(ExpList expList){
        int temp1,temp2;
        if(expList.kind==2){
            temp1 = resolveExp(((PairExpList)expList).head);
            temp2 = resolveExpList(((PairExpList)expList).tail);
            return temp1&amp;gt;temp2?temp1:temp2;
        }else if(expList.kind==1){
            return resolveExp(((LastExpList)expList).last);
        }else{
            return 0;
        }
    }
}
Interp.java
public class  Interp
{
    void startinterpStm(Stm stm){
        Table t=new Table(null,0,null);
        interpStm(stm,t);
    }
    Table interpStm(Stm stm,Table t){
        if(stm.kind==1){
            Table t1=interpStm(((CompoundStm)stm).stm1,t);
            Table t2=interpStm(((CompoundStm)stm).stm2,t1);
            return t2;
        }else if(stm.kind==2){
            IntAndTable it1 = interExp(((AssignStm)stm).exp,t);
            Table t1=update(it1.t,((AssignStm)stm).id,it1.i);
            return t1;
        }else if(stm.kind==3){
            printExplist(((PrintStm)stm).exps,t);
            return t;
        }else{
            return t;
        }
    }
    IntAndTable interExp(Exp exp,Table t){
        if(exp.kind==1){
            int temp=lookup(t,((IdExp)exp).id);
            return new IntAndTable(temp,t);
        }else if(exp.kind==2){
            return new IntAndTable(((NumExp)exp).num,t);
        }else if(exp.kind==3){
            IntAndTable it1= interExp(((OpExp)exp).left,t);
            IntAndTable it2= interExp(((OpExp)exp).right,it1.t);
            int x1,x2,result;
            x1=it1.i;
            x2=it2.i;
            if(((OpExp)exp).oper==1){
                result=x1+x2;
            }else if(((OpExp)exp).oper==2){
                result=x1-x2;
            }else if(((OpExp)exp).oper==3){
                result=x1*x2;
            }else if(((OpExp)exp).oper==4){
                result=x1/x2;
            }else{
                result=0;
            }
            return new IntAndTable(result,t);
        }else if(exp.kind==4){
            Table t1=interpStm(((EseqExp)exp).stm,t);
            IntAndTable t3= interExp(((EseqExp)exp).exp,t1);
            return t3;
        }else{
            return new IntAndTable(0,t);
        }
    }
    Table update(Table t1,String i,int v){
        Table t2=new Table(i,v,t1);
        return t2;
    }
    int lookup(Table t,String key){
        if(key.compareTo(t.id)==0){
            return t.value;
        }else return lookup(t.tail,key);
    }
    void printExplist(ExpList exps,Table t){
        if(exps.kind==1){
            IntAndTable temp=interExp(((LastExpList)exps).last,t);
            System.out.println(temp.i);
        }else if(exps.kind==2){
            IntAndTable temp=interExp(((PairExpList)exps).head,t);
            System.out.print(temp.i+&amp;quot;&amp;quot;);
            printExplist(((PairExpList)exps).tail,t);
        }else return;
    }
// IntAndTable interExpList(ExpList explist,Table t){
// }
}
class Table
{
    String id;
    int value;
    Table tail;
    Table(String i,int v,Table t){id=i;value=v;tail=t;}
}
class IntAndTable
{
    int i;
    Table t;
    IntAndTable(int ii,Table tt){i=ii;t=tt;};
}
&lt;/code&gt;&lt;/pre&gt;
- https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/ - Copyright (c) 2015. All rights reserved.</description>
        </item>
    
    
    
    
    
    
    
    
  </channel>
</rss> 