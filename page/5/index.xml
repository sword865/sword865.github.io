<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>悟剑阁</title>
    <link>https://sword865.github.io/</link>
    <description>Recent content on 悟剑阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2015. All rights reserved.</copyright>
    <lastBuildDate>Thu, 29 Jan 2026 21:55:26 +0800</lastBuildDate>
    
        <atom:link href="https://sword865.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>有重复组合数</title>
        <link>https://sword865.github.io/posts/archives/2009-04-02-%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%84%E5%90%88%E6%95%B0/</link>
        <pubDate>Thu, 02 Apr 2009 00:00:00 +0000</pubDate>
        
        <guid>https://sword865.github.io/posts/archives/2009-04-02-%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%84%E5%90%88%E6%95%B0/</guid>
        <description>悟剑阁 https://sword865.github.io/posts/archives/2009-04-02-%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%84%E5%90%88%E6%95%B0/ -&lt;p&gt;从n个元素中有重复地取r个，不计顺序，则不同的取法有多少种？&lt;br&gt;
这个问题的答案被称为有重复组合数。结果很简洁，是C(n+r-1,r)。(注：这表示从n+r-1个数中取出r个数的组合数)&lt;br&gt;
【证明1】&lt;br&gt;
我们先把原命题具体化。假设这n个元素就是1&lt;del&gt;n这n个数:       &lt;br&gt;
对于每一种选出来的组合a1，a2，a3，&amp;hellip; ，am，我们要求：a1&amp;lt;=a2&amp;lt;=a3&amp;lt;=&amp;hellip;&amp;lt;=ar，那么最终的目的就是找出这样的a(i)组数。&lt;br&gt;
这里我们构造b1=a1，b2= a2+1，&amp;hellip; ，b(i)= a(i)+(i-1)，&amp;hellip; ，b(r)= a(r)+(r-1)&lt;br&gt;
于是b(i)和a(i)一一对应，即所求a(i)组数对应于b(i)组数&lt;br&gt;
又因为 b1 &amp;lt; b2 &amp;lt; b3 &amp;lt; &amp;hellip; &amp;lt; br 且b(i)取值于1&lt;/del&gt; n+(r-1)&lt;br&gt;
亦即原命题等价于从1~ n+r-1中取得r个不重复排列数&lt;br&gt;
来源：&lt;a href=&#34;http://zhidao.baidu.com/question/16706714.html&#34;&gt;http://zhidao.baidu.com/question/16706714.html&lt;/a&gt;&lt;br&gt;
【证明2】&lt;br&gt;
将n个元素看做n个盒子,r看作r个无区别的球,则相当于:&lt;br&gt;
把r个同样的球放入n个顺次排列的盒子,求不计放球顺序的放法种数&lt;br&gt;
用0表示盒子,1表示球&lt;br&gt;
我们把这n个0和r个1写在一行上。&lt;br&gt;
由于球必须放在盒子中,规定某个0之前,到上一个0为止的1的个数,表示该盒子中装的球数&lt;br&gt;
注意到最后一个数必须是0&lt;br&gt;
所以相当于从前面n+r-1个位置中挑出r个位置放1，其余n-1个位置放0&lt;br&gt;
来源：&lt;a href=&#34;http://pengzhe0302.spaces.live.com/blog/cns!529d86ea9ec40ca2!113.entry&#34;&gt;http://pengzhe0302.spaces.live.com/blog/cns!529d86ea9ec40ca2!113.entry&lt;/a&gt;&lt;/p&gt;
&lt;div&gt;
  &lt;embed id=&#34;lingoes_plugin_object&#34; width=&#34;0&#34; height=&#34;0&#34; type=&#34;application/lingoes-npruntime-capture-word-plugin&#34; hidden=&#34;true&#34; /&gt;
&lt;/div&gt;
- https://sword865.github.io/posts/archives/2009-04-02-%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%84%E5%90%88%E6%95%B0/ - Copyright (c) 2015. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>终于还是开了个blog。。。</title>
        <link>https://sword865.github.io/posts/archives/2009-03-08-%E7%BB%88%E4%BA%8E%E8%BF%98%E6%98%AF%E5%BC%80%E4%BA%86%E4%B8%AAblog/</link>
        <pubDate>Sun, 08 Mar 2009 00:00:00 +0000</pubDate>
        
        <guid>https://sword865.github.io/posts/archives/2009-03-08-%E7%BB%88%E4%BA%8E%E8%BF%98%E6%98%AF%E5%BC%80%E4%BA%86%E4%B8%AAblog/</guid>
        <description>悟剑阁 https://sword865.github.io/posts/archives/2009-03-08-%E7%BB%88%E4%BA%8E%E8%BF%98%E6%98%AF%E5%BC%80%E4%BA%86%E4%B8%AAblog/ -&lt;p&gt;RT&lt;br&gt;
以后常来看看吧&lt;/p&gt;
- https://sword865.github.io/posts/archives/2009-03-08-%E7%BB%88%E4%BA%8E%E8%BF%98%E6%98%AF%E5%BC%80%E4%BA%86%E4%B8%AAblog/ - Copyright (c) 2015. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>编译原理虎书java版本–Chapter 1</title>
        <link>https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/</link>
        <pubDate>Sun, 08 Mar 2009 00:00:00 +0000</pubDate>
        
        <guid>https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/</guid>
        <description>悟剑阁 https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/ -&lt;p&gt;Count.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class  Count
{
    int resolveStm(Stm stm){
        int temp1=0,temp2=0;
        if(stm.kind==1){
            temp1=resolveStm(((CompoundStm)stm).stm1);
            temp2=resolveStm(((CompoundStm)stm).stm2);
            return temp1&amp;gt;temp2? temp1:temp2;
        }else if(stm.kind==2){
            return resolveExp(((AssignStm)stm).exp);
        }else if (stm.kind==3){
            return countExpInExpList(((PrintStm)stm).exps);
        }else{
            return 0;
        }
    }
    int countExpInExpList(ExpList expList){
        if(expList.kind==1){
            return 1;
        }else if(expList.kind==2){
            return 1+countExpInExpList(((PairExpList)expList).tail);
        }else{
            return 0;
        }
    }
    int resolveExp(Exp exp){
        int temp1,temp2;
        if(exp.kind==1){
            return 0;
        }else if(exp.kind==2){
            return 0;
        }else if(exp.kind==3){
            temp1 = resolveExp(((OpExp)exp).left);
            temp2 = resolveExp(((OpExp)exp).right);
            return temp1&amp;gt;temp2?temp1:temp2;
        }else if(exp.kind==4){
            temp1=resolveStm(((EseqExp)exp).stm);
            temp2=resolveExp(((EseqExp)exp).exp);
            return temp1&amp;gt;temp2?temp1:temp2;
        }else{
            return 0;
        }
    }
    int resolveExpList(ExpList expList){
        int temp1,temp2;
        if(expList.kind==2){
            temp1 = resolveExp(((PairExpList)expList).head);
            temp2 = resolveExpList(((PairExpList)expList).tail);
            return temp1&amp;gt;temp2?temp1:temp2;
        }else if(expList.kind==1){
            return resolveExp(((LastExpList)expList).last);
        }else{
            return 0;
        }
    }
}
Interp.java
public class  Interp
{
    void startinterpStm(Stm stm){
        Table t=new Table(null,0,null);
        interpStm(stm,t);
    }
    Table interpStm(Stm stm,Table t){
        if(stm.kind==1){
            Table t1=interpStm(((CompoundStm)stm).stm1,t);
            Table t2=interpStm(((CompoundStm)stm).stm2,t1);
            return t2;
        }else if(stm.kind==2){
            IntAndTable it1 = interExp(((AssignStm)stm).exp,t);
            Table t1=update(it1.t,((AssignStm)stm).id,it1.i);
            return t1;
        }else if(stm.kind==3){
            printExplist(((PrintStm)stm).exps,t);
            return t;
        }else{
            return t;
        }
    }
    IntAndTable interExp(Exp exp,Table t){
        if(exp.kind==1){
            int temp=lookup(t,((IdExp)exp).id);
            return new IntAndTable(temp,t);
        }else if(exp.kind==2){
            return new IntAndTable(((NumExp)exp).num,t);
        }else if(exp.kind==3){
            IntAndTable it1= interExp(((OpExp)exp).left,t);
            IntAndTable it2= interExp(((OpExp)exp).right,it1.t);
            int x1,x2,result;
            x1=it1.i;
            x2=it2.i;
            if(((OpExp)exp).oper==1){
                result=x1+x2;
            }else if(((OpExp)exp).oper==2){
                result=x1-x2;
            }else if(((OpExp)exp).oper==3){
                result=x1*x2;
            }else if(((OpExp)exp).oper==4){
                result=x1/x2;
            }else{
                result=0;
            }
            return new IntAndTable(result,t);
        }else if(exp.kind==4){
            Table t1=interpStm(((EseqExp)exp).stm,t);
            IntAndTable t3= interExp(((EseqExp)exp).exp,t1);
            return t3;
        }else{
            return new IntAndTable(0,t);
        }
    }
    Table update(Table t1,String i,int v){
        Table t2=new Table(i,v,t1);
        return t2;
    }
    int lookup(Table t,String key){
        if(key.compareTo(t.id)==0){
            return t.value;
        }else return lookup(t.tail,key);
    }
    void printExplist(ExpList exps,Table t){
        if(exps.kind==1){
            IntAndTable temp=interExp(((LastExpList)exps).last,t);
            System.out.println(temp.i);
        }else if(exps.kind==2){
            IntAndTable temp=interExp(((PairExpList)exps).head,t);
            System.out.print(temp.i+&amp;quot;&amp;quot;);
            printExplist(((PairExpList)exps).tail,t);
        }else return;
    }
// IntAndTable interExpList(ExpList explist,Table t){
// }
}
class Table
{
    String id;
    int value;
    Table tail;
    Table(String i,int v,Table t){id=i;value=v;tail=t;}
}
class IntAndTable
{
    int i;
    Table t;
    IntAndTable(int ii,Table tt){i=ii;t=tt;};
}
&lt;/code&gt;&lt;/pre&gt;
- https://sword865.github.io/posts/archives/2009-03-08-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%99%8E%E4%B9%A6java%E7%89%88%E6%9C%AC-chapter-1/ - Copyright (c) 2015. All rights reserved.</description>
        </item>
    
    
    
    
    
    
    
    
    
    
  </channel>
</rss> 