<!DOCTYPE html>
<html lang="en"><head>
	<meta name="generator" content="Hugo 0.145.0">
<title>悟剑阁</title>



  


<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5, user-scalable=5" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">















  






    <link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">

<link rel="stylesheet" href="/scss/dark-mode.min.cb53f1bee2b8900cb4f082afbf00175d6618f281cf9a2fe8619e3b52d20b5721.css" integrity="sha256-y1PxvuK4kAy08IKvvwAXXWYY8oHPmi/oYZ47UtILVyE=" media="screen">


<link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Material+Icons">


















<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>


</head>
<body>
    	<div id="app"><div class="single-column-drawer-container" id="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/posts">
                    Archive
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/about/">
                    关于
                </a>
                
            
            
        </div>
    </div>
</div>
<transition name="fade">
    <div id="drawer-mask" v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav id="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div id="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a id="navTitle" class="navbar-brand" href="https://sword865.github.io/">
            悟剑阁
        </a>
        
        <button type="button" class="nav-darkmode-toggle" id="darkModeToggleButton2">
            <i class="material-icons" id="darkModeToggleIcon2">
                dark_mode
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" id="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://sword865.github.io/">
        <div class="single-column-header-title">悟剑阁</div>
        

    </a>
</div>

            <div id="content">
                <div id="streamContainer" class="stream-container">

    <div class="post-list-container post-list-container-no-background">
        
        
            <a href="/posts/archives/2011-03-16-%E4%BD%BF%E7%94%A8ms3d%E4%B8%BAopengl%E5%BB%BA%E6%A8%A1/" class="a-block">
                <div class="post-item-wrapper">
                    <div class="post-item post-item-no-divider">
                        <div class="post-item-info-wrapper">
                            <div class="post-item-title">
                                简单讲一下使用MS3D为opengl建模
                            </div>
                            <div class="post-item-summary">
                                
                                    <p>做毕设的时候写的东西，贴上来吧…………</p>
<p>由于在OPENGL只能通过程序语言绘制模型，远不能达到可见既可得的目的。因此，比起3DMAX、MAYA等可视化3D建模工具，OPENGL模型的建立就相当的困难，为了简化这一问题的处理，可以使用简单小巧的MS3D来完成可见即可得的绘制过程。</p>
<p>MS3D的文件有着非常简单良好的文件结构，可从该文件中完美读取在可视工具中绘制的3D图形模型包含的点、线、面等各项基本结构的参数与位置，并在OPENGL根据读取结果即可进行绘制重现该模型。</p>
<p>MS3D全名为MilkShape3D，是一款简单小巧的3D可视化图形建模工具，可以简单的使用各种点、线面等基本图形元素组合建立模型，并进行贴图，分组。进一步的，该工具还支持简单的骨骼动画制作，是一款非常好用的3D图形构建工具。</p>
<p>[<img class="alignnone  wp-image-125" src="/wp-content/uploads/2015/02/ms3d-300x164.jpg" alt="ms3d" width="428" height="234" />][1]</p>
<p>在建立了MS3D中完成模型建立后可保存为.ms3d的文件格式，通过对该文件格式进行分析，就可以了解文件结构，以在程序中通过读取该文件重现所见模型。</p>
<p>该文件依次包括6段信息，除第一段文件头外，其它每段的开始位置都记录了该段中元素的数目，可用于计算该段的具体大小。</p>
<ul>
<li>
<p>文件头:大小固定为14字节。前10个字节为固定的标志 MS3D000000&lt;-其中后6个字节就是字符0（即值为48）后4个字节为该模型格式的版本号，这4个字节为一个有符号整数，目前该版本号的值为3或4，两种版本的格式细节不同。</p>
</li>
<li>
<p>点数据：紧接着文件头的就是模型的顶点数据部分，顶点部分的头两个字节为一个无符号整数，表示有多少个顶点。之后便是一个接一个的顶点的具体数据，包括可见性，x,y,z的坐标和绑定骨骼的ID编号(未绑定骨骼则为-1)。</p>
</li>
<li>
<p>多边形数据: 紧接着顶点数据的是多边形数据（三角形），多边形部分头两个字节是一个无符号整数，表示有多少个三角形。之后便是一个接一个的三角形数据。主要记录了每个三角形结构，包括顶点索引，顶点法线（用于光照计算），纹理坐标和组信息。</p>
</li>
<li>
<p>组信息：即网格信息，出于灵活性的考虑，模型的一个个三角形被按照网格或是组来划分。网格部分头两个字节是一个无符号整数，表示有得多少个网格。之后便是一个接一个的网格数据，每个网格结构的大小可能不同（因为他们拥有的三角形数不同）。主要包括网格的名字（字符串），三角形数量、三角形索引和材质索引（无材质则为-1）。</p>
</li>
<li>
<p>材质信息：贴图、颜色等材质部分。头两个字节是一个无符号整数，表示有多少个材质。之后便是一个接一个的材质信息。包括材质名、环境光、漫射光、高光、自发光、发光值、透明度、贴图文件名、透明贴图文件名。</p>
</li>
<li>
<p>骨骼信息： 动画、动作等。该结构是MS3D中的动态结构，仅当建立动态动画时存在，包括一种名为关键帧的结构，记录时间与对应的坐标系变换。骨骼信息，一开始是两个字节的无符号整数，表示一共有多少个骨骼，之后便是一个个的骨骼，骨骼的大小不是固定的。主要包括了骨骼名字，父骨骼名字，初始旋转与初始平移、以及之后的各个旋转与平移关键帧。</p>
</li>
</ul>
<p>在分析了解了MS3D的文件格式后，就可以通过编写程序读取MS3D文件并根据该文件建立模型了，对应于MS3D的不同分段，可以依次建立6种结构体分别对应每段内容：</p>
<pre><code>MS3DHeader     /\*包含ms3d文件的版本信息\*
MS3DVertex     /\*顶点信息\*/
MS3DMaterial   /\*材质(纹理贴图等)信息\*/
MS3DTriangle   /\*绘制三角形信息\*/
MS3DJoint      /\*节点(骨骼)信息\*/
MS3DKeyframe   /\*关键窗口\*/
//an example for vertex
struct MS3DVertex
{
  unsigned char m_ucFlags;   //编辑器用标志
  CVector3 m_vVert;        //x,y,z的坐标
  char m_cBone;        //Bone ID （-1 ,没有骨头）
  unsigned char m_mcUnused;      //保留，未使用
};
</code></pre>
<p>(1)第一个成员表示了该顶点在编辑器中的状态（引擎中不是必须）其各个值的含义如下：</p>
<p>0：顶点可见，未选中状态</p>
<p>1：顶点可见，选中状态</p>
<p>2：顶点不可见，未选中状态</p>
<p>3：顶点不可见，选中状态</p>
<p>(2)第二个成员为顶点的坐标，CVector3为三个float型组成，总共12字节</p>
<p>(3)第三个成员为该顶点所绑定的骨骼的ID号，如果该值为-1 则代表没有绑定任何骨骼（静态）</p>
<p>(4)第四个成员不包含任何信息，直接略过。</p>
<p>将MS3D各段内容分别导入对应的结构体，将其读入内存。</p>
<p>多边形（三角形）结构读取示范：</p>
<pre><code>//内存空间分配
// pPtr为文件读取偏移指针
int nTriangles = *( word* )pPtr;
m_numTriangles = nTriangles;
m_pTriangles = new Triangle[nTriangles];
pPtr += sizeof( word );
//读取每个三角型
for ( i = 0; i &amp;lt; nTriangles; i++ )
{
  MS3DTriangle *pTriangle = ( MS3DTriangle* )pPtr;
  int vertexIndices[3] = {
    pTriangle-&amp;gt;m_vertexIndices[0], 
    pTriangle-&amp;gt;m_vertexIndices[1], 
    pTriangle-&amp;gt;m_vertexIndices[2] 
  };
  float t[3] = { 1.0f-pTriangle-&amp;gt;m_t[0], 1.0f-pTriangle-&amp;gt;m_t[1], 1.0f-pTriangle-&amp;gt;m_t[2] };
  //数据读取
  memcpy( m_pTriangles[i].m_vertexNormals, pTriangle-&amp;gt;m_vertexNormals, sizeof( float )*3*3 );
  memcpy( m_pTriangles[i].m_s, pTriangle-&amp;gt;m_s, sizeof( float )*3 );
  memcpy( m_pTriangles[i].m_t, t, sizeof( float )*3 );
  memcpy( m_pTriangles[i].m_vertexIndices, vertexIndices, sizeof( int )*3 );
  //文件读取指针前进
  pPtr += sizeof( MS3DTriangle );
}
</code></pre>
<p>要注意得是，因为MS3D使用窗口坐标系而OpenGL使用笛卡儿坐标系，所以需要反转每个顶点Y方向的纹理坐标。</p>
                                
                            </div>
                            <div class="post-item-meta">
    2011-03-16
    &emsp;
    
    
    
    &emsp;
    
</div>

                        </div>
                        
                        
                    </div>
                </div>
        
            <a href="/posts/archives/2009-09-30-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%939-%E4%BC%98%E5%8C%96/" class="a-block">
                <div class="post-item-wrapper">
                    <div class="post-item post-item-no-divider">
                        <div class="post-item-info-wrapper">
                            <div class="post-item-title">
                                算法总结9—优化
                            </div>
                            <div class="post-item-summary">
                                
                                    <p>不同于之前的分类和聚类算法，优化的目的是尝试找到一个使成本函数输出最小化的值。这里主要包括两个算法：模拟退火算法和遗传算法。</p>
<p><strong>成本函数</strong>:<br>
接受一个经推测的题解，并返回一个数值结果，该值越大代表成本越高（题解表现越差），该值越小就表示题解越好。</p>
<p><strong>模拟退火算法：</strong></p>
<p>优化算法的目标可以看为寻找x使函数f(x)最小。</p>
<p>但是严格的最小值往往是很难达到的，我们不得不把眼光投入到寻找一个尽可能好的次优解去。</p>
<p>最简单的方法被称为随机法，即成千上万次的对x进行猜测，然后把这些x中使f(x)最小的一个作为答案。虽然这样很简单，但是效果很差。于是出现了爬山法。</p>
<p>爬山法从一个随机解出发，然后不断向该解附近的使f(x)的值更小的x移动，直到当前x附近的解都比x差为止。为了使效果更好，我们可以从多个随机解出发重复着一个过程，将最好的一个作为答案。很容易就能认识到，这样找到的解是一个极值点，是一个局部最小值。</p>
<p>爬山法虽然好，但是在其寻找最优解的过程中，前进的方向是固定的（使f(x)更小的方向），但是有时向其他方法前进也是必要的，因为f(x)可能先增大在变小成为最优的。</p>
<p>于是就有了模拟退火法。</p>
<p>该算法这源于固体的退火过程，即先将温度加到很高(大量原子被激发)，再缓慢降温(即退火)，则能使达到能量最低点。如果急速降温(即为淬火)则不能达到最低点。</p>
<p>模拟退火法同样是从一个随机解出发。但是它在寻找最优解时并不一定是向更好的x移动，也有一定的概率向更差的x移动，这个概率开始较大，但是会随时间而渐渐变小，直到稳定。一般该概率可以定义为：p=e ^ (-  (highcost – lowcost ) / temperature )，其中temperature是随时间增大而变小的温度，开始温度很高时p -&gt; 1，后来会渐渐变小使p-&gt;0。</p>
<p><strong>遗传算法：</strong></p>
<p>遗传算法的思想来自生物的遗传和变异，算法以种群为单位（一个种群为一组既多个解），其算法的运行过程如下：</p>
<ol>
<li>随机生成一组初始解（初始种群）。</li>
<li>计算种群中各个解的成本，然后进行排序。</li>
<li>我们将种群中靠前（成本低）的解保留下来，删除其他解，这一过程称为精英选拔。</li>
<li>对已有解进行微小的改变，将改变后的结果作为新的元素加入种群，这一过程称为变异。</li>
<li>选择一些优秀的解两两组合，然后将他们按某种方式进行结合（如求平均），将得到的结果作为新的元素加入种群，这一过程称为交叉（配对）。</li>
<li>不断重复2—5步，直到达到指定迭代次数或成本函数连续数代都没有更好的改善。</li>
<li>得到一组解，该组解为算法输出。</li>
</ol>
<p>该系列结束，恩，也许以后学了更多，有了更好的了解后会回来改一改，谁知道呢？</p>
                                
                            </div>
                            <div class="post-item-meta">
    2009-09-30
    &emsp;
    
    
    
    &emsp;
    
</div>

                        </div>
                        
                        
                    </div>
                </div>
        
            <a href="/posts/archives/2009-09-25-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%938-%E9%9D%9E%E8%B4%9F%E7%9F%A9%E9%98%B5%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/" class="a-block">
                <div class="post-item-wrapper">
                    <div class="post-item post-item-no-divider">
                        <div class="post-item-info-wrapper">
                            <div class="post-item-title">
                                算法总结8—非负矩阵因式分解
                            </div>
                            <div class="post-item-summary">
                                
                                    <p><strong>数学基础:</strong></p>
<p>线性代数的矩阵乘法运算。</p>
<p>   非负矩阵分解是一种特征提取的算法，它尝试从数据集中寻找新的数据行，将这些新找到的数据行加以组合，就可以重新构造出数据集。</p>
<p>   算法要求输入多个样本数据，每个样本数据都是一个m维数值向量，首先把我们的数据集用矩阵的形式写出来，每一列是一个数据，而每一行是这些数据对应维度的数值。于是我们就有了一个大小为m*n的输入矩阵。而算法的目标就是将这个矩阵分解为另外两个非负矩阵的积。</p>
<div>$$M_{m,n}=A_{m,r}B_{r,n}$$</div>
<p>   我们将分解矩阵后新得出的一个维度称为特征，那么在前一个m*r的矩阵中，第i行第j列的值就代表属性i对第j种特征的贡献值，而后一个矩阵的第i行第j列则代表第i种特征对第j个样本的贡献值。这样我们就找出了输入样本的r种特征。</p>
<p>   r的大小应该依照需要进行选择，比如如果是希望找到某些共性特征，则就要选择较小的r。当我们确定了一个较为合适的r值后，就要想办法确定后面两个矩阵具体的值了。</p>
<p>   书中给出的算法大致如下：</p>
<ol>
<li>定义一个函数计算用来两个矩阵的差异程度（每个对应元素相减后平方的和）</li>
<li>随机生成2个矩阵(m<em>r维和r</em>n维)记为A（权重矩阵）,B（特征矩阵）</li>
<li>计算A<em>B与输入的m</em>n的数据矩阵的差异，足够小则停止，否则继续</li>
<li>按一定规则调整A，B的值后转3.</li>
</ol>
<p>对于调整的方法，可以用模拟退火（下一篇文章中会提到）等多种算法，书里使用的是乘法更新法则，该法则我没有认真去看….感兴趣的可以去看论文….英文的…</p>
<p><a href="http://hebb.mit.edu/people/seung/papers/nmfconverge.pdf">http://hebb.mit.edu/people/seung/papers/nmfconverge.pdf</a>.</p>
<p>算法如下：</p>
<p>hn 转置后的权重矩阵和数据矩阵相乘的结果</p>
<p>hd 转置后的权重矩阵和原权重矩阵相乘再乘特征矩阵的结果</p>
<p>wn数据矩阵与转置后的特征矩阵相乘的结果</p>
<p>wd权重矩阵与特征矩阵相乘，再与转置后的特诊矩阵相乘得到的矩阵</p>
<p>为了更新特征矩阵和权重矩阵，我们先把上面所有矩阵变为数组．然后把特征矩阵中每一个值与hn中对应值相乘，并除以hd中对应的值．类似的，我们再将权重矩阵中每一个值与wn中的对应值相乘，并除以wd中对应的值．</p>
<p>最近的算法都很好理解的样子…不过写起来还是挺麻烦的….还有最后一篇优化了，内容挺多，包括模拟退火和遗传算法….恩</p>
<div>
  <embed id="lingoes_plugin_object" width="0" height="0" type="application/lingoes-npruntime-capture-word-plugin" hidden="true" />
</div>
                                
                            </div>
                            <div class="post-item-meta">
    2009-09-25
    &emsp;
    
    
    
    &emsp;
    
</div>

                        </div>
                        
                        
                    </div>
                </div>
        
            <a href="/posts/archives/2009-09-20-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%937-%E5%A4%9A%E7%BB%B4%E7%BC%A9%E6%94%BE/" class="a-block">
                <div class="post-item-wrapper">
                    <div class="post-item post-item-no-divider">
                        <div class="post-item-info-wrapper">
                            <div class="post-item-title">
                                算法总结7—多维缩放
                            </div>
                            <div class="post-item-summary">
                                
                                    <p>一直没有时间写…..唉</p>
<p>这个东西好像是属于数据可视化？反正就是把多维的数据降到低维空间但是仍然尽可能的保持原来数据之间的距离关系(就是在原来维度下离的远的点仍然离得远，接近的点仍然接近) 。最常见的应该就是降到2维以方便打印和屏幕输出。</p>
<p>算法的输入是所有数据在高维情况下两两之间的距离（记i与j的距离为Dij）。现在以降到2维为例说明这个算法。</p>
<p>首先我们把所有数据点随机绘制在一张二维图像上，然后计算它们两两之间的距离dij，然后我们计算出它与高维距离Dij的误差，根据这些误差，我们将每对数据点按比例移近或移远，然后重新计算所有dij，不断重复到我们没法减少误差为止。</p>
<p>还是来具体说明一下吧，假设有n个点</p>
<ol>
<li>输入每一对点之间的距离Dij。</li>
<li>随机在2维平面生成n个点，点i坐标记为x[i]、y[i]，计算它们两之间的距离，记为dij.</li>
<li>对所有i 和j计算：eij=(dij-Dij) / Dij，每个点用一个二维的值grad[k]来表示它要移动的距离的比例因子(初始为0,0)。在计算出每个eij后，计算 ((x[i]-x[j]) / dij)* eij，然后把它加到grad[i][x]上，同样把((y[i]-y[j]) / dij)* eij加到grad[i][y]上。</li>
<li>把所有eij的绝对值相加，为总误差，与前一次的总误差比较(初始化为无穷大)，大于前一次的话就停止。否则把它作为上一次总误差，继续。</li>
<li>对每个点，新的坐标为x[i] -= rate * grad[i][x]  y[i] -= rate*grad[i][y]，其中rate是开始时自己定义的一个常数参数，该参数影响了点的移动速度。重新计算各个dij，回到3。</li>
</ol>
<p>伪码：</p>
<pre tabindex="0"><code>    for m = 1 to 1000{
      for i=1 to n
        for  j = 1 to n
          dij=sqrt((x[i] – x[j])^2+(y[i]-y[j])^2)
      for i=1 to n
        gradi=0
      totale=0
      for i= 1 to n
        for j= 1 to n{
           if(j==i) continue
             eij=(dij-Dij) / Dij
             grad[i][0]+= ((x[i] - x[j]) / dij)* eij
             grad[i][1]+=((y[i] - y[j]) / dij)* eij
             totale+=abs(eij)
           }
      if (laste &amp;lt; totale) break;
      laste=totale
      for i=1 to n{
        x[i] -= rate * grad[i][x]
        y[i] - = rate* grad[i][y]
      }
    }
</code></pre><p> </p>
                                
                            </div>
                            <div class="post-item-meta">
    2009-09-20
    &emsp;
    
    
    
    &emsp;
    
</div>

                        </div>
                        
                        
                    </div>
                </div>
        
            <a href="/posts/archives/2009-09-14-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%9356-k-%E6%9C%80%E8%BF%91%E9%82%BB%E4%B8%8E%E8%81%9A%E7%B1%BB/" class="a-block">
                <div class="post-item-wrapper">
                    <div class="post-item post-item-no-divider">
                        <div class="post-item-info-wrapper">
                            <div class="post-item-title">
                                算法总结5&amp;6—-k-最近邻与聚类
                            </div>
                            <div class="post-item-summary">
                                
                                    <p>因为这两个算法比较简单，又有些相似，所以这里放在一起。</p>
<p><strong>K-最近邻：</strong></p>
<p>k-最近邻也是一种用来进行预测的算法。</p>
<p><strong>工作原理：</strong></p>
<p>接受一个用以进行数值预测的新数据项，然后将它与一组已经赋过值的数据项进行比较。算法会从中找出与待预测数据最为接近的k项，并这k项其求均值以得到最终的结果。</p>
<p>总计来说这是一个很简单的算法，只要我们做好距离的定义并选择一个适合的k值，我们就可以很容易的实现它。</p>
<p>由于我们计算2组数据的距离的通常方法是将他们中对应的每一项目的差值的绝对值(或平方)相加，所以就会出现不同数据范围不同导致的误差。比如每组数据有2个分量，一个取值为0—10,另一个是0—-999999，那么第二的值就会几乎完全决定我们最后的结果。所以我们要对每一组数据进行缩放。</p>
<p>对数据的缩放取决于具体的应用，我们可以通过交叉验证尝试多组缩放因子然后比较它们的优劣。交叉验证的做法是先数据的一部分去除，然后用剩余数据去推测这组数据，我们就可以根据预测的结果对缩放因子进行评估。</p>
<p><strong>优点：</strong></p>
<p>能利用复杂函数进行数值预测，又简单易懂，并且我们可以很容易的在算法中实现查看用哪些近邻进行预测。</p>
<p><strong>缺点：</strong></p>
<p>每次进行预测，它都会使用所有样本，这会导致效率的低下。</p>
<p>寻找缩放因子是一项很乏味的工作.</p>
<p><strong>聚类：</strong></p>
<p>聚类算法可以用于任何具有一个或多个数值属性的数据集合，通过这些数值属性，我们将其所有数据映射到一个n维空间中，并定义该空间中的距离，然后我们可以通过各个数据间的距离对其实现聚类。</p>
<p><strong>分级聚类:</strong></p>
<p>分级聚类的算法是不断找出所有数据中距离最小的两个数据A、B，然后将它们合并成一个新的节点，该节点在n维空间中的坐标是原来两数据点的均值，通过不断进行这一操作，我们最终可以得到一个树形的层级结构。</p>
<p><strong>K-均值聚类:</strong></p>
<p>不同于分级聚类，K-均值聚类的目的是将数据拆成K个不同的群组，其具体算法如下：</p>
<ol>
<li>在n维空间中随机生成K个中心点</li>
<li>将每个数据项分配给与其距离最近的中心点。</li>
<li>将中心点位置移动到所有分配给它的数据项的中心。如果中心点位置没有改变，则结束算法，否则回到第二步。</li>
</ol>
<p>具体选择哪种聚类算法取决于要处理的问题，当要将数据拆分到不同的群组时，k均值聚类往往是很有价值的，而如果我们更想了解哪些群组间更为接近，分级聚类更好。当然，我们也可以同时使用２种算法得到更加详细的信息。</p>
<div>
  <embed id="lingoes_plugin_object" width="0" height="0" type="application/lingoes-npruntime-capture-word-plugin" hidden="true" />
</div>
                                
                            </div>
                            <div class="post-item-meta">
    2009-09-14
    &emsp;
    
    
    
    &emsp;
    
</div>

                        </div>
                        
                        
                    </div>
                </div>
        
            <a href="/posts/archives/2009-09-10-%E7%BB%9F%E8%AE%A1%E9%80%BB%E8%BE%91%E4%B8%8E%E6%99%BA%E8%83%BD/" class="a-block">
                <div class="post-item-wrapper">
                    <div class="post-item post-item-no-divider">
                        <div class="post-item-info-wrapper">
                            <div class="post-item-title">
                                统计,逻辑与智能
                            </div>
                            <div class="post-item-summary">
                                
                                    <p>      今天上了开学的第一节统计学，开了很久的小差，想了不少东西。</p>
<p>      以前虽然自学过概率论与数理统计，但是也只是了解了一些公式与原理，一直对于统计学的一些应用不甚理解(或者说不能接受)，尤其是基于统计的机器学习，一直不能接受它作为一种实现的人工智能的手段。因为我心中的人工智能是绝对理性，严谨，逻辑的。虽然我可以接受统计学的理论，却不能把它作为一种严谨的逻辑。</p>
<p>　 但是，今天突然想到了感性，是的，人是理性的，但是人的思维中也充满了感性的，当然，这是早已熟知的事实。</p>
<p>　 先给感性下一个定义吧。</p>
<p>　 感性：作用于人的感觉器官而产生的感觉，知觉和表象等直观认识，相对与‘理性’”</p>
<p>　 是的，感性一种直观的认识，那么这种认识从哪里来呢？过去的经验。人们的感性是在经验的基础上建立的，是一种仅仅由经验得出而没有任何逻辑背景的判断。</p>
<p>　 统计学不也是这样么？将大量的样本作为过去的经验，仅仅由这些经验而不带任何逻辑推断的去快速做出一种“感性”的判断。只是这种感性比人的感性更加严谨，不会受到类似“小概率事件经常发生”这种错觉的影响，但也可以算是一种理性的感性了。</p>
<p>      对应的，我又想起了逻辑学，如果统计是根据经验快速简单的做出判断的话，那么逻辑学就是通过严谨的逻辑推理去寻找正确的答案，这个过程会很繁琐，但是它使绝对严谨理性的，比我们的大脑更加严谨，理性——那何不把它看成一种是理性的理性呢？</p>
<p>     但是仅仅有统计与逻辑，我们无法建立一个系统，因此也许还需要一个驱动吧？在完成一个任务、解决一个问题时，这个驱动不断的让感性提供可能解，然后让理性验证它——突然我发现，这不就是“启发式搜索”所作的事情么？</p>
<p>     以前翻过一些人工智能的书，总是觉的虽然那些方法可以达到目的，但是却没有触及到智能的本质，因此总是有些失望的，可是现在，我释然了。什么是智能的本质？好像是在《与众不同的心理学》这本书上，我看到过类似问题(也许问得是别的什么，不过差不多)。书里说，这是不可验证的，如果我们甚至不能解释，验证它，我们为什么可以凭借自己的主观推断去确定一个机器是否拥有智能？我们凭什么可以认为，这些机器，当他们把现在这些技术发挥到一定程度后就不可以拥有智能？也许我们自己的自我认知也只是一种数学的算法对自身产生的作用呢？（是不是有谁说过，这个宇宙，连同我们的存在，都只是一种错觉？记不清了…..不过看来这句话还是很有意思的。）</p>
<p>　 想到了这些之后，我对“人工智能最难的是处理常识”第一次有了很深的认同，以前总是不能充分认识常识的作用，但是如果直觉，经验在智能中占了如此重要的一部分，那么我们就必须去处理常识――其中的困难自然不用多说了。</p>
<p>     最后，把我上课时写在书上的话记录下来吧：</p>
<p>     统计学—以理性研究感性，我们的直觉从过去的经验去推导未来，这种推断不能解释结果的原因。（因为它在历史上倾向于如此，所以它很可能如此。）统计学将这种感性理性化，并出除了一些直觉上的错误（如：小概率事件经常发生），但其根本上还是一种感性的判断，因此解释这种感性推断背后的原因，事物呈现这种状态的原因，就是人的工作了。所以统计学也可以用来在没有线索时，作为一种“事后诸葛亮”式的推断的第一步（即先找出最可能答案，在设法解释它，不过这种方法具有不可证伪性，所以不是科学严谨的――毕竟是直觉么）。同时，统计的机器学习可以就可用来模拟人的直觉学习了（而且是一种没有错误的直觉）。</p>
                                
                            </div>
                            <div class="post-item-meta">
    2009-09-10
    &emsp;
    
    
    
    &emsp;
    
</div>

                        </div>
                        
                        
                    </div>
                </div>
        
            <a href="/posts/archives/2009-09-08-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%934-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" class="a-block">
                <div class="post-item-wrapper">
                    <div class="post-item post-item-no-divider">
                        <div class="post-item-info-wrapper">
                            <div class="post-item-title">
                                算法总结4—支持向量机
                            </div>
                            <div class="post-item-summary">
                                
                                    <p>支持向量机……复杂的东西，书里讲得也不怎么详细，起码具体算法没有说……所以又去查了些资料……</p>
<p>支持向量机是用来对数据进行分类的。</p>
<p>首先从最简单的情况开始吧：</p>
<p>如果有一条直线，我们把它看成一条数轴，上面有一些样本点，其中坐标大于某个值的点都属于一类，坐标小于某个值的点都属于一类，那么我们就可以用这个值来做分分界点，它点把直线上的点分为了两类。因为样本点是有限可数的。所以这个分类点的取法不唯一。选好后，随便给我们一个点，我们就可以根据这个随机给出的点是在分界点的左侧还是右侧来判断这个点的类别。</p>
<p>同样，一个平面上有很多样本点，这些点也分为2类，如果我们在平面上可以找到这样一条直线满足这两类样本点分别分布在直线的两侧，那么我们就可以用这个平面作分界面，来对之后随机给出的点进行分类。</p>
<p>仍然用同样的方法，我们可以用一个平面给分布在一个3维立体空间中的点分类。</p>
<p>总结起来就是说：在n维空间中有很多样本点，如果我们能找到一个n-1维的超平面，这个平面恰好把空间中的样本点分在它的两侧，那么我们就可以用这个n-1维的超平面来对之后随机给出点分类。</p>
<p>这种方法有两个问题：</p>
<p>1）  因为那个n-1维的超平面选法往往是不唯一的，我们要选哪一个?</p>
<p>2）  更多情况下，我们找不到这样一个n-1维超平面，你可以想象更多情况下，我们要分类的数据是“混合”在一起的，很难简单的用一个点，一条线，或者一个更高纬度的线性分类器把它分开。</p>
<p>接下来我们就要来解决这个问题。</p>
<p><strong>最优超平面的确定:</strong></p>
<p>如果选择合适的分界超平面呢？直观的来说，我们因该选择一个距离两组数据“最远”的超平面。首先每个点都和这个超平面有一个距离（该距离可以通过把n维空间放入一个n维坐标系后用代数的方法计算出来，具体计算过程此处就不说了。不过1维２维３维的情况你应该能自己算出来吧～～～，理解就好）我们选择的超平面要让所有这些距离中最小的一个值最大。</p>
<p>我们在n维空间空建立一个n维坐标系</p>
<p>在这个n维坐标系中，每个n-1维超平面都可一个用一个方程表示出来，这里设为。</p>
<div>$$H(x)=a_{0}+\sum_{i=1}^{n}(a_{i}*x_{i})$$</div>
<p>我们用一个变量Y表示一个点相对超平面的关系，在一侧为1.另一侧为-1.</p>
<p>可以证明:（证明过程略）</p>
<p>该平面在满足下面的约束时：</p>
<div>$Y_{i}H_(x_{i})\geq 1$</div>
<p>极小化函数</p>
<div>$\frac{1}{2}\sum_{j=1}^{n}(a_{j}^{2})$</div>
<p>这是一个二次规划问题，我们对它求解就可以得到最优平面。</p>
<p>有时我们找不到这样一个超平面，这时，我们可以把超平面的约束条件放的宽松一点，也就是在超平面附近允许两种分类的点的重叠，可以同过把改为（e&gt;0）来实现这一目的。</p>
<p>（具体证明与求解参考《统计学完全教程》 科学出版社 P290的支持向量机一节）</p>
<p><strong>第二个问题的解决—核方法</strong></p>
<p>很多时候，我们是找不到一个简单的超平面对样本进行划分的，这个时候，我们可以通过坐标变换，把样本点映射到一个可以线形划分的空间中。</p>
<p>这个映射可以是同维度的，即映射前后样本空间的纬度相同，比如：</p>
<p><img src="http://pic002.cnblogs.com/images/2012/52809/2012063021394557.jpg" alt=""></p>
<p>就可以通过一个简单的<strong>求平方</strong>运算，把数据从线性不可划分变为线性可分—我们可以很容易的找到一条直线把后者的样本点分成两个部分。</p>
<p>但是很多时候，问题没有这么简单，我们就需要用另外一种映射，即把样本点映射到更高纬度的空间去。</p>
<p>比如上面的左图还可以做这么一种变换：</p>
<p>$$z_1=x_1x_1, z_2=\sqrt{2}x_1x_2, z_3=x_2x_2$$</p>
<p>这样我们就可以在新的样本空间中很简单的找到一个平面把这些点分开了．仔细分析，你可以发现，这个平面其实是左图中的一个椭圆的经过上述变换后得到的．</p>
<p><strong>较高维空间的线性分类器对应于原空间的一个非线性分类器．</strong></p>
<p>这就是<strong>核方法</strong>的核心。</p>
<p>通过找到一个合适的映射，我们就可以前面的问题(2)了</p>
<p>这种映射称为核函数，核函数的选择是很有技巧的，它也有一些常见的模型，很多时候我们只要选择合适的模型并计算适当的参数就可以了。具体方法这里不说了，有兴趣的可以参见《<a href="http://download.csdn.net/source/1353188">RBF核函数的支持向量机参数选择</a>》一文。</p>
<p>找到核函数后，我们就完全解决上述问题了。</p>
<p>（其实这里还有一些简化计算的技巧，这些技巧与其它更具体的东西还是可以去看《统计学完全教程》 科学出版社，真是一本非常强大的书。）</p>
<p><strong>优点:</strong></p>
<p>可以很快的判断一个样本的种类。</p>
<p><strong>缺点:</strong></p>
<p>由于对每个数据集的最佳核变换及相应参数都不一样，所以对每个数据集都要重新学习确定函数与参数。</p>
<p>一般而言，支持向量机更适合包含大量数据的问题，而其他方法如决策树，更适合小规模的数据集。</p>
<p>支持向量机也是一种黑盒技术，由于存在像高维空间的判断，我们很难解释分类的具体标准与原因。</p>
<div>
  <embed id="lingoes_plugin_object" width="0" height="0" type="application/lingoes-npruntime-capture-word-plugin" hidden="true" />
</div>
<p style="margin:0;padding:0;height:1px;overflow:hidden;">
  <a href="http://www.wumii.com/widget/relatedItems" style="border:0;"><img src="http://static.wumii.cn/images/pixel.png" alt="无觅相关文章插件，快速提升流量" style="border:0;padding:0;margin:0;" /></a>
</p>
                                
                            </div>
                            <div class="post-item-meta">
    2009-09-08
    &emsp;
    
    
    
    &emsp;
    
</div>

                        </div>
                        
                        
                    </div>
                </div>
        
            <a href="/posts/archives/2009-09-07-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%933-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" class="a-block">
                <div class="post-item-wrapper">
                    <div class="post-item post-item-no-divider">
                        <div class="post-item-info-wrapper">
                            <div class="post-item-title">
                                算法总结3—神经网络
                            </div>
                            <div class="post-item-summary">
                                
                                    <p><strong>生物神经网络：</strong></p>
<p><strong>    </strong> 在生物的神经网络中的基本单位是神经元，神经元与神经元之间是由突触的相互联系来传递信息的，在静止息状态时，神经元的膜的内外电压保持一种稳定状态（膜内电压低于膜外电压），当神经元受到刺激后，在被刺激的部分周围，这种平衡状态会被打破，电压改变，与没有受到刺激的部分形成电流传递信息，电流的强弱取决于受刺激部位电压的改变量。</p>
<p>     前一个神经元的轴突末梢作用于下一个神经元的胞体、树突或轴突等处组成突触。不同的轴突末梢可以释放不同的化学物质对下一个神经元产生不同的影响。也就是说会使下一个神经元的受刺激部分产生不同的电压，也就导致了不同程度的电流，最终也就传递了完全不同的信息。</p>
<p>     一个神经元可以通过轴突作用于成千上万的神经元，也可以通过树突从成千上万的神经元接受信息。当多个神经元同时对一个神经元产生作用时，结果这些神经元的作用强度共同决定。</p>
<p>     神经系统按功能可大致分为传入神经（感觉神经）、中间神经（脑：延脑、脑桥、小脑、中脑、间脑、大脑脊髓）与传出神经（运动神经）三类。</p>
<p>     感受神经的作用是接受外界信息（输入），中间神经则起到了信息传递与计算分析的作用，最用，传出神经会负责对外界信息作出相应的反应（输出）。</p>
<p>     模仿这一过程，我们就可以建立人工神经网络。</p>
<p><strong>人工神经网络：</strong></p>
<p>     人工神经网络的基本单位是人工神经元（以下简称神经元）。一个神经元可以有多个输入，每个输入有一个相应权值。</p>
<p>图示如下：</p>
<img class="alignnone  wp-image-125" src="http://upload.wikimedia.org/wikipedia/commons/9/97/Ncell.png" alt="nn" />
<pre><code>a1~an为神经元的输入值
w1~wn为神经元各个的输入所拥有的权值
b为偏移量
sum对各个输入与其权值的积求和(含偏移量)。
f为传递函数，接受sum的输出，通过一个函数变换，输出t
t为神经元输出
数学表示 t=f(WA'+b)
W为权向量
A为输入向量，A'为A向量的转置
b为偏移量
f为传递函数
</code></pre>
<p>在人工神经网络中，神经元之间相互连接，在连接点将前者的输出作为后者的输出，形成错综复杂的网状结构，进行信息的传递与计算。</p>
<p>我们这里要介绍的是其中比较简单的一种模型，称为“多层感知机（MLP）”网络。</p>
<p>为了简化模型，我们假设偏移量b=0.</p>
<p>多层感知机网络由3部分组成：</p>
<p>输入层：功能类似感受神经，每个节点接受外界的直接输入。这里的模型中，每个节点接受单一输入，权值为1。</p>
<p>输出层：功能类似运动神经，该层输出就是神经网络的输出。</p>
<p>隐藏层：是输入层和输出层之间的多层神经网络，可以有1或多层。</p>
<p>因此，MLP网络中至少有3个层次。</p>
<img class="alignnone  wp-image-125" src="/images/archives/2012063021381464.jpg" alt="mlp" />
<p>这些层次中，每层的每个神经元的输出都会作为下一层的每个神经元的输入，因此当我们对输入层进行输入后，该信息会一层层传递下去，最终从输出层输出。</p>
<p>神经网络建立后，我们需要设法确定每个神经元的各个输入的权重w，并选择合适的函数f对输入进行变换，只有完成以上工作后，我们才能使用神经网络完成相应的工作。</p>
<p>我们一般会选择过关于源点对称的S形函数作为函数f，该种函数特点是:输入接近0时，函数对输入的变化有敏感的反应，这一敏感度将随输入绝对值的增大而下降，最终趋于0。</p>
<p><strong>权重的获取：</strong></p>
<p>选择合适的函数后，我们就要去确定各权重w了，权重的选择取决于我们想要神经网络完成的任务，我们首先会给每个输入一个初始化的默认值，该值可任意选取。</p>
<p>完成初始化后，我们就要开始训练神经网络了，即给神经网络大量的已知的正确的输入及其对应的输出，神经网络会将自己得到到的输出与正确输出向比较，然后根据某一算法调整自身的权重，使自身输出更接近正确答案。</p>
<p>我们这里要介绍的调整算法称为<strong>反向传播法</strong>，因为该算法是沿网络反向调整权值的。</p>
<p>这一算法中，我们会分析输出与正确答案，并将将输出向正确答案推进，为了了解如何推进，我们需要一个函数来计算函数f的斜率，设该函数为g。根据该函数，我们可以计算sum因改变的值。</p>
<p>整个算法如下：</p>
<p>从后向前对输出层和所有隐含层：</p>
<p>1）  计算节点当前输出与期望结果的差值d。(期望结果t – 实际输出 y)</p>
<p>对输出层: t在输入训练数据时一同输入。</p>
<p>对隐含层: t = sum ( 前一层的每个节点的差值di * 这两个节点间连线的权值 )</p>
<p>2）  利用函数g确定函数f在节点输出值y处的改变速率v。v=g(y)</p>
<p>3）  改变每个输入链接的权值，其改变量与链接的当前输入强度与学习速率rate（自己定义的属于(0,1)的常量）成正比。</p>
<p>（每个wi的改变量为（v<em>d</em>rate*输入ai））</p>
<p>这样一层层的从后向前反推，最终完成对一个训练样本的学习。</p>
<p>当对所有样本完成训练后，我们就可以使用这个神经网络了。</p>
<p>比如，我们想用神经网络模拟一个数学函数，我们先向网络提供大量的正确的输入输出进行训练，然后就可以用神经网络作模拟这个函数进行计算了。</p>
<p><strong>优点：</strong></p>
                                
                            </div>
                            <div class="post-item-meta">
    2009-09-07
    &emsp;
    
    
    
    &emsp;
    
</div>

                        </div>
                        
                        
                    </div>
                </div>
        
            <a href="/posts/archives/2009-09-06-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%932-%E5%86%B3%E7%AD%96%E6%A0%91%E5%88%86%E7%B1%BB%E5%99%A8/" class="a-block">
                <div class="post-item-wrapper">
                    <div class="post-item post-item-no-divider">
                        <div class="post-item-info-wrapper">
                            <div class="post-item-title">
                                算法总结2—决策树分类器
                            </div>
                            <div class="post-item-summary">
                                
                                    <p><strong>数学基础：</strong></p>
<p>树：树是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<p>每个结点有零个或多个子结点；</p>
<p>每一个子结点只有一个父结点；</p>
<p>没有前驱的结点为根结点；</p>
<p>除了根结点外，每个子结点可以分为m个不相交的子树；</p>
<p>没有子节点的节点称为叶节点。</p>
<p><strong>决策树分类器原理：</strong></p>
<p>决策树是一颗树，要分类的样本从树根进入，在树的每个节点通过对样本的某种属性的判断选择不同的路径逐步下降到底,得出其所属类别。</p>
<p>例图:</p>
<p><img src="http://pic002.cnblogs.com/images/2012/52809/2012063021362216.jpg" alt=""></p>
<p>为了建立一棵决策树,我们首先应向程序输入大量训练数据(包含所属类别的数据)，程序将根据训练数据按某一算法自动生成决策树。</p>
<p><strong>决策树生成算法:</strong></p>
<p>   为了构造决策树，算法首先创建一个根节点，然后通过分析训练数据，逐步选出适合的变量对数据进行拆分(即逐步构造上图中的非叶子节点。)</p>
<p>   为了选择适合的变量对数据进行拆分，我们需要一个方法来评估一种拆分方案的好坏，<strong>其评估方法包括：</strong></p>
<ol start="2">
<li><strong>基尼不纯度：</strong></li>
</ol>
<p>定义：基尼不存度是指来自集合的某种结果随机应用于集合中某一数据的预期误差。（如果集合中所有结果属于同一类，则误差为0）</p>
<p>使用：利用这一思想，我们可以将集合中每种类别的数据出现的次数除以数据总数计算相应概率，再将这些概率的乘积相加（所有概率两两相乘后在相加），这样就会得到某一数据被随机分配到错误结果的总概率。</p>
<p>伪代码：</p>
<pre><code>imp=0
for k1 in kinds
    p1=count(k1) / total
    for k2 in counts
        if (k1==k2)continue
        p2=count(k2) / total
        imp+=p1*p2
ans=imp
</code></pre>
<p align="left">
  &nbsp;&nbsp; (p1*p2是一个p1类别的数据被当作p2的概率)
</p>
<ol start="2">
<li>**熵：**在信息论中，熵代表的是集合的无序程度—–基本上就相当于我们在此处所说的集合的混杂程度。</li>
</ol>
<p>熵的值是遍历所有结果后得到的pi*log2(pi)的和的绝对值</p>
<p>伪代码：</p>
<pre><code>ent=0.0
for k in kinds
    p=count(k) / total
    ent=ent – p*log2(p)     // 因为0&lt;p&lt;=1，所以必有log2(p)&lt;=0
ans=ent
</code></pre>
<p>有了上述评估方法后，我们就可以不断尝试各种拆分方法，然后选出最好的拆分方法构造树中的节点了。我们将计算拆分前的熵（基尼不存度）值，与拆分后的熵（基尼不存度）的值的加权平均，将其差值作为<strong>信息增益</strong>。最终对能得到最大信息增益的属性进行拆分。然后再分别对拆分后得集合选择属性进行拆分，直到最大信息增益为非正时停止拆分，这时决策树就构建完毕了。</p>
<p><strong>优化：</strong></p>
<p>为了防止决策树变的过度拟合（过度针对训练数据），我们可以在信息增益小于某个值后就停止拆分。但是我们可能遇到这样的数据―――某次拆分信息增益很小，但下一次就会很大。为了防止这一状况，我们可以在用先前的方法构造整棵树后，在尝试消除多余的节点。这个过程就是<strong>剪枝</strong>。</p>
<p>剪枝的过程就是对具有相同父节点的节点进行检查，判断将其合并后，信息增益是否会小于某个指定发值。若是，则合并这些节点。合并后节点包括所有可能的结果值。</p>
<p><strong>在处理数值型数据时，熵和基尼不存度并不是一个好的选择，因为有些数值相差很近，有些相差很远，不能简单用是否为同一类别进行判断。所以我们可以用方差代替它们。</strong></p>
<p><strong>决策树对缺失数据的处理：</strong></p>
<p>当我们要判断类别的样本缺少某些决策树作判断时必须的数据时，我们可以选择同时走两个分支，不过我们不是平均统计各分支的结果值，而是进行加权统计。为了达到这一目标，决策树中每个节点都有一个值为１的权重，即观测数据对于数据向是否属于某个特定分类的概率具有１００％的影响，而如果走多个分支，我们将给每个分支一个权重，其值等于所有位于该分支的其他数据所占的比重。</p>
<p><strong>优点：</strong></p>
<p>决策树最大的优势是它可以轻易对一个受训模型给予解释。（解释分类原理）</p>
<p>决策树可以同时接受分类型和数值型数据。</p>
<p>比起贝叶斯分类器（参考**[&lt;集体智慧编程&gt;算法总结1—贝叶斯分类器][2]**）决策树可以更好的处理变量间的相互影响。</p>
                                
                            </div>
                            <div class="post-item-meta">
    2009-09-06
    &emsp;
    
    
    
    &emsp;
    
</div>

                        </div>
                        
                        
                    </div>
                </div>
        
        </a>
    </div>


                    </div>
            </div><div id="sideContainer" class="side-container">
    
    <a class="a-block nav-head active" href="https://sword865.github.io/">
    
        <div class="nav-title">
            悟剑阁
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/posts">
                Archive
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/about/">
                关于
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
Ported from <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	Copyright (c) 2015. All rights reserved.
	

    </div>
    
</div><div id="extraContainer" class="extra-container">
    <div class="toc-wrapper">
        

        
    </div>
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top"
            :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a type="button" class="pagination-action" id="darkModeToggleButton">
            <span class="material-icons pagination-action-icon" id="darkModeToggleIcon">
                dark_mode
            </span>
        </a>
        
        
        

        <a class="pagination-action"  href="/page/2/">
            
            <i class="material-icons pagination-action-icon">
                chevron_left
            </i>
        </a>

        <div class="pagination-indicator">
            <span style="text-align: center">
                3<br>
                <div style="display: inline-block; transform: rotate(-28deg)">-</div><br>5
            </span>
        </div>


        <a class="pagination-action"  href="/page/4/">
            
            <i class="material-icons pagination-action-icon">
                chevron_right
            </i>
        </a>
        
        
    </div>
</div>


<div class="pagination">
    
    <a class="pagination-action" href="/page/2/" style="opacity:1">
    
        <i class="material-icons pagination-action-icon">
            chevron_left
        </i>
    </a>

        <div class="pagination-indicator">
            <span>3/5</span>
        </div>

        
        <a class="pagination-action" href="/page/4/"
           style="opacity:1">
        
                <i class="material-icons pagination-action-icon">
                    chevron_right
                </i>
            </a>
</div>



<div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
Ported from <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	Copyright (c) 2015. All rights reserved.
	
</div>
            </div>
    
    <script src="/js/journal.js"></script></body>
</html>
