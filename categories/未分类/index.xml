<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>未分类 on 悟剑阁</title>
    <link>https://sword865.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/</link>
    <description>Recent content in 未分类 on 悟剑阁</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2015. All rights reserved.</copyright>
    <lastBuildDate>Wed, 16 Mar 2011 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://sword865.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>简单讲一下使用MS3D为opengl建模</title>
      <link>https://sword865.github.io/archives/124/</link>
      <pubDate>Wed, 16 Mar 2011 00:00:00 +0000</pubDate>
      <guid>https://sword865.github.io/archives/124/</guid>
      <description>&lt;p&gt;做毕设的时候写的东西，贴上来吧…………&lt;/p&gt;&#xA;&lt;p&gt;由于在OPENGL只能通过程序语言绘制模型，远不能达到可见既可得的目的。因此，比起3DMAX、MAYA等可视化3D建模工具，OPENGL模型的建立就相当的困难，为了简化这一问题的处理，可以使用简单小巧的MS3D来完成可见即可得的绘制过程。&lt;/p&gt;&#xA;&lt;p&gt;MS3D的文件有着非常简单良好的文件结构，可从该文件中完美读取在可视工具中绘制的3D图形模型包含的点、线、面等各项基本结构的参数与位置，并在OPENGL根据读取结果即可进行绘制重现该模型。&lt;/p&gt;&#xA;&lt;p&gt;MS3D全名为MilkShape3D，是一款简单小巧的3D可视化图形建模工具，可以简单的使用各种点、线面等基本图形元素组合建立模型，并进行贴图，分组。进一步的，该工具还支持简单的骨骼动画制作，是一款非常好用的3D图形构建工具。&lt;/p&gt;&#xA;&lt;p&gt;[&lt;img class=&#34;alignnone  wp-image-125&#34; src=&#34;https://sword865.github.io/wp-content/uploads/2015/02/ms3d-300x164.jpg&#34; alt=&#34;ms3d&#34; width=&#34;428&#34; height=&#34;234&#34; /&gt;][1]&lt;/p&gt;&#xA;&lt;p&gt;在建立了MS3D中完成模型建立后可保存为.ms3d的文件格式，通过对该文件格式进行分析，就可以了解文件结构，以在程序中通过读取该文件重现所见模型。&lt;/p&gt;&#xA;&lt;p&gt;该文件依次包括6段信息，除第一段文件头外，其它每段的开始位置都记录了该段中元素的数目，可用于计算该段的具体大小。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;文件头:大小固定为14字节。前10个字节为固定的标志 MS3D000000&amp;lt;-其中后6个字节就是字符0（即值为48）后4个字节为该模型格式的版本号，这4个字节为一个有符号整数，目前该版本号的值为3或4，两种版本的格式细节不同。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;点数据：紧接着文件头的就是模型的顶点数据部分，顶点部分的头两个字节为一个无符号整数，表示有多少个顶点。之后便是一个接一个的顶点的具体数据，包括可见性，x,y,z的坐标和绑定骨骼的ID编号(未绑定骨骼则为-1)。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多边形数据: 紧接着顶点数据的是多边形数据（三角形），多边形部分头两个字节是一个无符号整数，表示有多少个三角形。之后便是一个接一个的三角形数据。主要记录了每个三角形结构，包括顶点索引，顶点法线（用于光照计算），纹理坐标和组信息。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;组信息：即网格信息，出于灵活性的考虑，模型的一个个三角形被按照网格或是组来划分。网格部分头两个字节是一个无符号整数，表示有得多少个网格。之后便是一个接一个的网格数据，每个网格结构的大小可能不同（因为他们拥有的三角形数不同）。主要包括网格的名字（字符串），三角形数量、三角形索引和材质索引（无材质则为-1）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;材质信息：贴图、颜色等材质部分。头两个字节是一个无符号整数，表示有多少个材质。之后便是一个接一个的材质信息。包括材质名、环境光、漫射光、高光、自发光、发光值、透明度、贴图文件名、透明贴图文件名。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;骨骼信息： 动画、动作等。该结构是MS3D中的动态结构，仅当建立动态动画时存在，包括一种名为关键帧的结构，记录时间与对应的坐标系变换。骨骼信息，一开始是两个字节的无符号整数，表示一共有多少个骨骼，之后便是一个个的骨骼，骨骼的大小不是固定的。主要包括了骨骼名字，父骨骼名字，初始旋转与初始平移、以及之后的各个旋转与平移关键帧。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在分析了解了MS3D的文件格式后，就可以通过编写程序读取MS3D文件并根据该文件建立模型了，对应于MS3D的不同分段，可以依次建立6种结构体分别对应每段内容：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;MS3DHeader     /\*包含ms3d文件的版本信息\*&#xD;&#xA;MS3DVertex     /\*顶点信息\*/&#xD;&#xA;MS3DMaterial   /\*材质(纹理贴图等)信息\*/&#xD;&#xA;MS3DTriangle   /\*绘制三角形信息\*/&#xD;&#xA;MS3DJoint      /\*节点(骨骼)信息\*/&#xD;&#xA;MS3DKeyframe   /\*关键窗口\*/&#xD;&#xA;//an example for vertex&#xD;&#xA;struct MS3DVertex&#xD;&#xA;{&#xD;&#xA;  unsigned char m_ucFlags;   //编辑器用标志&#xD;&#xA;  CVector3 m_vVert;        //x,y,z的坐标&#xD;&#xA;  char m_cBone;        //Bone ID （-1 ,没有骨头）&#xD;&#xA;  unsigned char m_mcUnused;      //保留，未使用&#xD;&#xA;};&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;(1)第一个成员表示了该顶点在编辑器中的状态（引擎中不是必须）其各个值的含义如下：&lt;/p&gt;&#xA;&lt;p&gt;0：顶点可见，未选中状态&lt;/p&gt;&#xA;&lt;p&gt;1：顶点可见，选中状态&lt;/p&gt;&#xA;&lt;p&gt;2：顶点不可见，未选中状态&lt;/p&gt;&#xA;&lt;p&gt;3：顶点不可见，选中状态&lt;/p&gt;&#xA;&lt;p&gt;(2)第二个成员为顶点的坐标，CVector3为三个float型组成，总共12字节&lt;/p&gt;&#xA;&lt;p&gt;(3)第三个成员为该顶点所绑定的骨骼的ID号，如果该值为-1 则代表没有绑定任何骨骼（静态）&lt;/p&gt;&#xA;&lt;p&gt;(4)第四个成员不包含任何信息，直接略过。&lt;/p&gt;&#xA;&lt;p&gt;将MS3D各段内容分别导入对应的结构体，将其读入内存。&lt;/p&gt;&#xA;&lt;p&gt;多边形（三角形）结构读取示范：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;//内存空间分配&#xD;&#xA;// pPtr为文件读取偏移指针&#xD;&#xA;int nTriangles = *( word* )pPtr;&#xD;&#xA;m_numTriangles = nTriangles;&#xD;&#xA;m_pTriangles = new Triangle[nTriangles];&#xD;&#xA;pPtr += sizeof( word );&#xD;&#xA;//读取每个三角型&#xD;&#xA;for ( i = 0; i &amp;amp;lt; nTriangles; i++ )&#xD;&#xA;{&#xD;&#xA;  MS3DTriangle *pTriangle = ( MS3DTriangle* )pPtr;&#xD;&#xA;  int vertexIndices[3] = {&#xD;&#xA;    pTriangle-&amp;amp;gt;m_vertexIndices[0], &#xD;&#xA;    pTriangle-&amp;amp;gt;m_vertexIndices[1], &#xD;&#xA;    pTriangle-&amp;amp;gt;m_vertexIndices[2] &#xD;&#xA;  };&#xD;&#xA;  float t[3] = { 1.0f-pTriangle-&amp;amp;gt;m_t[0], 1.0f-pTriangle-&amp;amp;gt;m_t[1], 1.0f-pTriangle-&amp;amp;gt;m_t[2] };&#xD;&#xA;  //数据读取&#xD;&#xA;  memcpy( m_pTriangles[i].m_vertexNormals, pTriangle-&amp;amp;gt;m_vertexNormals, sizeof( float )*3*3 );&#xD;&#xA;  memcpy( m_pTriangles[i].m_s, pTriangle-&amp;amp;gt;m_s, sizeof( float )*3 );&#xD;&#xA;  memcpy( m_pTriangles[i].m_t, t, sizeof( float )*3 );&#xD;&#xA;  memcpy( m_pTriangles[i].m_vertexIndices, vertexIndices, sizeof( int )*3 );&#xD;&#xA;  //文件读取指针前进&#xD;&#xA;  pPtr += sizeof( MS3DTriangle );&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;要注意得是，因为MS3D使用窗口坐标系而OpenGL使用笛卡儿坐标系，所以需要反转每个顶点Y方向的纹理坐标。&lt;/p&gt;</description>
    </item>
    <item>
      <title>统计,逻辑与智能</title>
      <link>https://sword865.github.io/archives/17/</link>
      <pubDate>Thu, 10 Sep 2009 00:00:00 +0000</pubDate>
      <guid>https://sword865.github.io/archives/17/</guid>
      <description>&lt;p&gt;      今天上了开学的第一节统计学，开了很久的小差，想了不少东西。&lt;/p&gt;&#xA;&lt;p&gt;      以前虽然自学过概率论与数理统计，但是也只是了解了一些公式与原理，一直对于统计学的一些应用不甚理解(或者说不能接受)，尤其是基于统计的机器学习，一直不能接受它作为一种实现的人工智能的手段。因为我心中的人工智能是绝对理性，严谨，逻辑的。虽然我可以接受统计学的理论，却不能把它作为一种严谨的逻辑。&lt;/p&gt;&#xA;&lt;p&gt;　 但是，今天突然想到了感性，是的，人是理性的，但是人的思维中也充满了感性的，当然，这是早已熟知的事实。&lt;/p&gt;&#xA;&lt;p&gt;　 先给感性下一个定义吧。&lt;/p&gt;&#xA;&lt;p&gt;　 感性：作用于人的感觉器官而产生的感觉，知觉和表象等直观认识，相对与‘理性’”&lt;/p&gt;&#xA;&lt;p&gt;　 是的，感性一种直观的认识，那么这种认识从哪里来呢？过去的经验。人们的感性是在经验的基础上建立的，是一种仅仅由经验得出而没有任何逻辑背景的判断。&lt;/p&gt;&#xA;&lt;p&gt;　 统计学不也是这样么？将大量的样本作为过去的经验，仅仅由这些经验而不带任何逻辑推断的去快速做出一种“感性”的判断。只是这种感性比人的感性更加严谨，不会受到类似“小概率事件经常发生”这种错觉的影响，但也可以算是一种理性的感性了。&lt;/p&gt;&#xA;&lt;p&gt;      对应的，我又想起了逻辑学，如果统计是根据经验快速简单的做出判断的话，那么逻辑学就是通过严谨的逻辑推理去寻找正确的答案，这个过程会很繁琐，但是它使绝对严谨理性的，比我们的大脑更加严谨，理性——那何不把它看成一种是理性的理性呢？&lt;/p&gt;&#xA;&lt;p&gt;     但是仅仅有统计与逻辑，我们无法建立一个系统，因此也许还需要一个驱动吧？在完成一个任务、解决一个问题时，这个驱动不断的让感性提供可能解，然后让理性验证它——突然我发现，这不就是“启发式搜索”所作的事情么？&lt;/p&gt;&#xA;&lt;p&gt;     以前翻过一些人工智能的书，总是觉的虽然那些方法可以达到目的，但是却没有触及到智能的本质，因此总是有些失望的，可是现在，我释然了。什么是智能的本质？好像是在《与众不同的心理学》这本书上，我看到过类似问题(也许问得是别的什么，不过差不多)。书里说，这是不可验证的，如果我们甚至不能解释，验证它，我们为什么可以凭借自己的主观推断去确定一个机器是否拥有智能？我们凭什么可以认为，这些机器，当他们把现在这些技术发挥到一定程度后就不可以拥有智能？也许我们自己的自我认知也只是一种数学的算法对自身产生的作用呢？（是不是有谁说过，这个宇宙，连同我们的存在，都只是一种错觉？记不清了…..不过看来这句话还是很有意思的。）&lt;/p&gt;&#xA;&lt;p&gt;　 想到了这些之后，我对“人工智能最难的是处理常识”第一次有了很深的认同，以前总是不能充分认识常识的作用，但是如果直觉，经验在智能中占了如此重要的一部分，那么我们就必须去处理常识――其中的困难自然不用多说了。&lt;/p&gt;&#xA;&lt;p&gt;     最后，把我上课时写在书上的话记录下来吧：&lt;/p&gt;&#xA;&lt;p&gt;     统计学—以理性研究感性，我们的直觉从过去的经验去推导未来，这种推断不能解释结果的原因。（因为它在历史上倾向于如此，所以它很可能如此。）统计学将这种感性理性化，并出除了一些直觉上的错误（如：小概率事件经常发生），但其根本上还是一种感性的判断，因此解释这种感性推断背后的原因，事物呈现这种状态的原因，就是人的工作了。所以统计学也可以用来在没有线索时，作为一种“事后诸葛亮”式的推断的第一步（即先找出最可能答案，在设法解释它，不过这种方法具有不可证伪性，所以不是科学严谨的――毕竟是直觉么）。同时，统计的机器学习可以就可用来模拟人的直觉学习了（而且是一种没有错误的直觉）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>读《你的灯亮这么》—走出问题的乌托邦</title>
      <link>https://sword865.github.io/archives/22/</link>
      <pubDate>Tue, 25 Aug 2009 00:00:00 +0000</pubDate>
      <guid>https://sword865.github.io/archives/22/</guid>
      <description>&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  军训期间闲着无聊时,决定读一些&amp;ldquo;杂书&amp;rdquo;，其中有一本叫《你的灯亮着么?》的小册子，刚读完不久，趁着今晚休息的时间作以记录。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  &lt;strong&gt;1)&lt;/strong&gt;&lt;strong&gt;动手解决问题前，好好想想问题的来源。2)如何从各个角度看待问题，找到其真正所在。3)为什么不要把人们的解决方法误以为是问题的定义，更不要把某个问题的解决方法误认为是问题的定义，特别是整个解决方法是你自己所使用的。4)永远不要肯定你已经有了一个正确的定义，即使是在问题好像已经解决之后。5)每一种解决方法都会带来新的问题。6)问题最难处理的部分恰恰是去意识到它们的存在。7)在理解问题前，至少要做好准别接受三种可能的出错情况。8)或许还可以改变问题的表述来获得不同的解决方法。9)当你沉迷于寻找问题的定义和解决方法时，不要忘记随时都回头看看，看看自己是不是已经迷路了&amp;hellip;。10)当别人能很好的解决自己的问题时，千万不要越俎代庖。11)如果某人能够解决这个问题，但是他们并不会遇到这一问题时，那么你首先要做的就是让他们也感受一下问题。12)不管看上去如何，人们很少知道他们要什么，直到你给了他们所需要东西。13)甚至，事实上，并没有多少人真的希望他们的问题被解决。&lt;/strong&gt;&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  以上摘自书中序言。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  解决问题前，我们自然要先明确问题，比如问题的对象，问题的内容等等，虽然问题本身并不会有一个通俗简单的定义。但是书中的一种说法确实让人耳目一新&amp;#8212;-&amp;ldquo;&lt;strong&gt;问题就是你所期望的东西和你体验的东西之间的差别&lt;/strong&gt;&amp;rdquo;。对问题的定义是非常重要的―――同样是具有风险的，很多人在问题的定义中徘徊，因为他们不愿承担定义失误的风险。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  作为一个问题的解决者，为了定义一个问题（当然，它并不唯一），我们可以利用经典的分治算法把一个问题变为一系列的问题。为了实现这一转变，我们需要去回答另外一些问题&amp;#8212;比如&amp;ldquo;谁有问题&amp;rdquo;&amp;ldquo;问题的本质是什么&amp;rdquo;&amp;ldquo;问题是谁引起的&amp;rdquo;等等。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  当我们做出了一个比较适合的定义后，我们就可以着手去解决它。由于&amp;ldquo;问题就是你所期望的东西和你体验的东西之间的差别&amp;rdquo;，我们可以从两个方面入手&amp;#8212;-&lt;strong&gt;要么改变期望，要么改变体验&lt;/strong&gt;。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  要改变体验，有很多种方法，书中举例说&amp;ldquo;很多人觉得等待电梯的时间太久&amp;rdquo;―――&amp;ldquo;那么我们的期望的就是更加快速有效的乘坐电梯，体验则是漫长的等待&amp;rdquo;，而解决方法是―――&amp;ldquo;在等待电梯的拐角放上一面镜子&amp;rdquo;――――&amp;ldquo;对着镜子整理衣着减少了人们体验到的时间&amp;rdquo;。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  你从例子中体验到了什么?我悟到的是&amp;ldquo;&lt;strong&gt;体验!=(不等于)现实&lt;/strong&gt;&amp;rdquo;，我们可以在不对现实做出任何改变的同时，用某种手段改变人们的体验。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  但是在解决这一问题后是什么呢?&amp;#8212;-新的问题&amp;#8212;有人在镜子上乱涂乱画！我们的问题解决者不得不继续想办法去解决它。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  &lt;strong&gt;如果你想找到一个问题的解决方法，试试&amp;ldquo;让情况变得更糟&amp;rdquo;&lt;/strong&gt;。基于这个原则，问题解决者把在镜子上涂画变成了一种娱乐的活动&amp;#8212;效果是一样的，人们不会觉得电梯来得太慢了&amp;#8212;他们甚至觉得来得太快了，不是么？&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  在结束这一章时，书中继续了那个很有趣的电梯的故事&amp;#8212;&amp;ldquo;在他们讨论解决问题时，曾经用说笑的口气提出过偷取隔壁大楼电梯使用时间的方法，但是被否决了。后来问题解决者发现隔壁大楼是一座百货商场，而且商场最近生意还不怎么样&amp;#8212;他们巴不得有人去偷取他们的电梯时间呢！&amp;rdquo;文中的结论是&amp;ldquo;对那些没有幽默感的人，帮他们解决问题简直就是自寻烦恼&amp;rdquo;（因为他对这个说笑口气提出的解决方案给予了严肃的批评），我觉得，这告诉我们，&lt;strong&gt;很多方案，我们并不能只从印象和表面去判断他是否可行&amp;#8212;-因为那并不可靠。&lt;/strong&gt;&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  然后是一个新的故事&amp;#8212;-在这里不对那个故事进行复述了，我觉得这个故事中最重要的结论是&amp;ldquo;&lt;strong&gt;不要把他们的解决方法误认为是问题的定义&lt;/strong&gt;&amp;rdquo;即是说，我们要自己去了解问题，而不要从别人那里&amp;#8212;尤其是他们的解决方案那里得到问题的答案。很多时候我们试图从别人那里去得到问题的定义，但是那永远是局部的，这和我们在做题做不出时，会去重读题目一样&amp;#8212;最原始的资料，虽然最难以使用，但却又是最为有效的。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  另外一个结论是：&lt;strong&gt;如果你太轻易地解决了他们的问题，他们永远都不会相信你真的解决了他们的问题。&lt;/strong&gt;&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  人总是过于自信的，这使他们不愿承认自己错误的估计了一个问题的难度。这使得我们有时为了解决一个问题，会浪费比解决问题更多的时间去说服哪些人&amp;#8212;&amp;#8211;为了避免这一点，我们必须在适当的时候承认自己的愚昧和无知。当然，倒过来想，绝大多数问题可以是简单的，只是我们用错了方法，走错了方向。仅此而已。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  在下一个故事中，再次强调了以下的事实：&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  &lt;strong&gt;每一种解决问题的方法都会到来新的问题。我们永远都不能消灭问题。问题、解决问题的方法和新的问题编织成一条无穷无尽的锁链。在解决一个问题的时候，要找出至少三个可能出现的新问题，否则说明我们对于当前问题的理解还不够透彻。&lt;/strong&gt;&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  另外：&lt;strong&gt;问题最难以处理的部分恰恰是去意识到它们的存在。&lt;/strong&gt;如果我们能够意识到问题的存在，那么很多问题是很容易解决的。一个典型的例子是交通限速与交通事故的关系。当能源危机使美国限速减低到55英里时，交通事故大量减少。但是在这以前呢？我们常把原因归因与酒后驾车等问题,根本没有人意识到他们习以为常的交通限速根本就不合理！这是因为我们思维中的惯性的存在。因此，换一个身份进行思考，（孩子，外国人等等）也许你会对问题有一个全新的解读。因为很多我们习以为常的东西其实并不合理，或者说并不完美。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  这也就代入了&amp;ldquo;问题的表述&amp;rdquo;的问题，不同的问题表述可以给我们不同的解决方案，同样会带来不同的新的问题。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  &amp;nbsp;只要我们记得对自己提问：&amp;ldquo;&lt;strong&gt;我们要怎样改变问题的表述才能获得不同的解决方法？&lt;/strong&gt;&amp;rdquo;也许我们就能得到不同表述与答案。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  一个简单的例子是一个简单的圆。我们可以问&amp;ldquo;这个物体是什么?&amp;rdquo;，也可以问&amp;ldquo;这个常见的物体什么?&amp;rdquo;&amp;ldquo;这个不常见的物体是什么?&amp;rdquo;你的答案一定会大不一样吧。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  这里我又想到了一个加鸡蛋的故事：&amp;ldquo;您要加鸡蛋么？&amp;rdquo;&amp;ldquo;您要加一个还是两个鸡蛋？&amp;rdquo;这样提问的两家商店可以有着完全不同的营业额。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  提问的内容与方法确实可以制约到人的思维，进而控制了我们的答案。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p&gt;这其实是一种文字游戏。&lt;/p&gt;&#xA;&lt;p&gt;有时我们可以利用它，有时我们却要减少文字引起的不确定性，因此，一旦你用文字来表述一个问题，请仔细推敲这些文字以使这种表述在每个人的头脑中都是一个意思。&lt;/p&gt;&#xA;&lt;p&gt;    另外，由于问题中存在的种种陷阱**：**&lt;strong&gt;当你在寻找问题定义的道路上疲倦地游荡时，不要忘记随时都回头看看，看看你是不是已经迷路了。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  又是新的故事。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  如果一些人产生了问题，你最好不要随便的插干涉它&amp;#8212;&amp;ldquo;&lt;strong&gt;当别人能够很好地解决自己问题的时候，千万不要越俎代庖。&lt;/strong&gt;&amp;rdquo;因为外力的入侵或许会使问题产生一些我们事先没有想到的变化&amp;#8212;-比如引入新的变量，改变问题的性质等等。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  如果这是他们的麻烦，就让它成为他们的麻烦吧。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  &amp;nbsp;&amp;nbsp; &amp;nbsp;但是当你无法解决你所解决的问题而需要寻求帮助时，你也许会发现有人可以轻易的解决它。你要如何寻找帮助呢?威逼和利诱都不是最好的选择&amp;#8212;-&lt;strong&gt;你只需要让他也感受到这一问题的存在。&lt;/strong&gt;（当然，这不是永远有效的，因为也许那个人根本就不在乎，或者他会认为你是在给他捣乱！）&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  如果你用尽方法都行不通的话，&lt;strong&gt;为什么不试试指责你自己呢&lt;/strong&gt;？人们倾向于在别人身上寻找问题，确不会降低自己的期望。还记得我们对问题的定义么&amp;ldquo;问题其实就是你期望的东西和你体验的东西之间的差别&amp;rdquo;除了改变体验外，降低期望同样是一种方法&amp;#8212;-虽然你并不喜欢。但是事实是，很多问题的根源在你自己身上。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  不得不提的是书中最经典的一个例子:在一个隧道的入口处有一个照牌&amp;ldquo;警告：前有隧道请打开车头灯&amp;rdquo;，那么隧道的出口呢？&amp;ldquo;请关灯？&amp;rdquo;如果是晚上呢？也许我们可以用非常麻烦的语法分析各种情况写出一个完美的招牌，但是谁会去读它？最简单的方法是&amp;ldquo;如果这是他的问题，把问题留给他好了&amp;rdquo;&amp;#8212;简单的在牌子上写上&amp;ldquo;&lt;strong&gt;你的灯亮这么&lt;/strong&gt;&lt;strong&gt;?&lt;/strong&gt;&amp;rdquo;&amp;#8212;我们没有必要为所有人解决一个对每个人都很简单，组合起来确又非常复杂的问题，不是么？&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  最后，书中讨论了一个很奇怪的问题&amp;ldquo;我们真的想解决问题么？&amp;rdquo;虽然很奇怪，但是这种情况确实经常出现。也许你只是在享受问题解决过程的乐趣，也许你解决问题是为了否定它,谁知道呢?&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  最后的最后，是书中的最后说明的一句话：&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p&gt;  &lt;strong&gt; ****“首先，对自己要真诚。”&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt; &lt;strong&gt;“&lt;strong&gt;&lt;strong&gt;This above all&lt;/strong&gt;&lt;/strong&gt;，&lt;/strong&gt; &lt;strong&gt;to thine own self be true&lt;/strong&gt;**。”**&lt;/p&gt;&#xA;&lt;p&gt;    在解决和定义一个问题前：“道德是最为重要的”&lt;/p&gt;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  &amp;nbsp;&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  &amp;nbsp;&amp;nbsp;&amp;nbsp; 虽然文章已经结束了，我还是想把书中一个很有趣的问题及解决与大家分享，这来自书的序篇。&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  序篇&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  问题：没有人会阅读序言&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  解决方法：把序言称为第一章&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  解决方法带来的新问题：第一章是单调沉闷的&#xD;&#xA;&lt;/p&gt;&#xD;&#xA;&lt;p align=&#34;left&#34;&gt;&#xD;&#xA;  再次解决：把第一章扔了，再把第二章称为第一章&#xD;&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title>终于还是开了个blog。。。</title>
      <link>https://sword865.github.io/archives/27/</link>
      <pubDate>Sun, 08 Mar 2009 00:00:00 +0000</pubDate>
      <guid>https://sword865.github.io/archives/27/</guid>
      <description>&lt;p&gt;RT&lt;br&gt;&#xA;以后常来看看吧&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
